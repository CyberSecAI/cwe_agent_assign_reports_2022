{
  "retriever": "sparse",
  "query": "## Vulnerability Description\nAn **integer overflow** in CrwMapencode0x1810 of Exiv2 0.27.3 allows attackers to trigger a **heap-based buffer overflow** and cause a denial of service (DOS) via crafted metadata.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **integer overflow**\n- **weakness:** **heap-based buffer overflow**\n- **impact:** denial of service\n- **vector:** crafted metadata\n- **attacker:** attackers\n- **product:** Exiv2\n- **version:** 0.27.3\n- **component:** CrwMapencode0x1810\n\n## CVE Reference Links Content Summary\n```\n{\n  \"guidelines\": \"1. First verify if the content relates to the CVE specified based on the official description\\n2. If the content does not relate to this CVE, respond with \\\"UNRELATED\\\"\\n3. If no useful vulnerability information is found, respond with \\\"NOINFO\\\" \\n4. For relevant content, extract:\\n   - Root cause of vulnerability\\n   - Weaknesses/vulnerabilities present\\n   - Impact of exploitation\\n   - Attack vectors\\n   - Required attacker capabilities/position\\n\\nAdditional instructions:\\n- Preserve original technical details and descriptions\\n- Remove unrelated content\\n- Translate non-English content to English\\n- Note if the content provides more detail than the official CVE description\",\n  \"response\": {\n    \"CVE-2021-31292\": {\n      \"description\": \"The provided content contains information about CVE-2021-31292, which is an integer overflow in CrwMap::encode0x1810 leading to a heap-based buffer overflow and DoS. \",\n      \"information\": [\n        {\n          \"source\": \"lists.fedoraproject.org_d7e66bda_20250114_230433.html\",\n          \"content\": \"CVE-2021-31292 mingw-exiv2: exiv2: Integer overflow in CrwMap:encode0x1810 leading to heap-based buffer overflow and DoS [fedora-all]\"\n        },\n        {\n           \"source\": \"www.debian.org_d3f369e7_20250114_230436.html\",\n           \"content\": \"CVE ID : CVE-2019-20421 CVE-2021-3482 CVE-2021-29457 CVE-2021-29473 CVE-2021-31292 Several vulnerabilities have been discovered in Exiv2, a C++ library and a command line utility to manage image metadata which could result in denial of service or the execution of arbitrary code if a malformed file is parsed.\"\n         },\n        {\n          \"source\": \"security.gentoo.org_6f56c49b_20250114_230435.html\",\n          \"content\": \"* [CVE-2021-31292](https://nvd.nist.gov/vuln/detail/CVE-2021-31292)\"\n        },\n        {\n           \"source\": \"lists.fedoraproject.org_718fdc19_20250114_230434.html\",\n           \"content\": \"CVE-2021-31292 mingw-exiv2: exiv2: Integer overflow in CrwMap:encode0x1810 leading to heap-based buffer overflow and DoS [fedora-all]\"\n         },\n        {\n          \"source\": \"lists.debian.org_a624310b_20250114_230431.html\",\n           \"content\": \"CVE ID         : CVE-2019-20421 CVE-2021-3482 CVE-2021-29457 CVE-2021-29473 CVE-2021-31291 CVE-2021-31292\\nSeveral vulnerabilities have been discovered in Exiv2, a C++ library and a command line utility to manage image metadata which could result in denial of service or the execution of arbitrary code if a malformed file is parsed.\"\n         },\n        {\n          \"source\": \"github.com_4808aacc_20250114_230430.html\",\n          \"content\": \"heap-buffer-overflow Read in Exiv2::Internal::CrwMap::encode #1530\\n\\nVERSION exiv 2 0.27.4.1 \\n\\nREPRODUCE Compile exiv2 with asan:\\n\\nCC=clang CXX=clang++ cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\\\"-fsanitize=address\\\" \\\\\\n-DCMAKE_C_FLAGS=\\\"-fsanitize=address\\\" -DCMAKE_EXE_LINKER_FLAGS=\\\"-fsanitize=address\\\" \\\\\\n-DCMAKE_MODULE_LINKER_FLAGS=\\\"-fsanitize=address\\\"\\n\\nDowload testcases:\\n\\nhttps://github.com/henices/pocs/raw/master/tests_1bd0a5f4935b053f33ac00f931dde1f47a043487 https://github.com/henices/pocs/raw/master/tests_1bd0a5f4935b053f33ac00f931dde1f47a043487.exv\\n\\nRun command: `exiv2 in tests_1bd0a5f4935b053f33ac00f931dde1f47a043487`\\n\\n=================================================================\\n==119384==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62600000585e at pc 0x0000004c4d0a bp 0x7ffef1036370 sp 0x7ffef1035b20\\nREAD of size 4294967293 at 0x62600000585e thread T0\\n   #0 0x4c4d09 in __asan_memcpy (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4c4d09)\\n   #1 0x7f40c9907d88 in Exiv2::Internal::CrwMap::encode0x1810(Exiv2::Image const&, Exiv2::Internal::CrwMapping const*, Exiv2::Internal::CiffHeader*) (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x4c8d88)\\n   #2 0x7f40c9911007 in Exiv2::Internal::CrwMap::encode(Exiv2::Internal::CiffHeader*, Exiv2::Image const&) (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x4d2007)\\n   #3 0x7f40c9769376 in Exiv2::CrwImage::writeMetadata() (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x32a376)\\n   #4 0x541653 in (anonymous namespace)::metacopy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, bool) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x541653)\\n   #5 0x545049 in Action::Insert::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x545049)\\n   #6 0x4fddf3 in main (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4fddf3)\\n   #7 0x7f40c8ede1e1 in __libc_start_main /usr/src/debug/glibc-2.32-37-g760e1d2878/csu/../csu/libc-start.c:314:16\\n   #8 0x4224cd in _start (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4224cd)\\n0x62600000585e is located 0 bytes to the right of 10078-byte region [0x626000003100,0x62600000585e) allocated by thread T0 here:\\n   #0 0x4fad47 in operator new[](unsigned long) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4fad47)\\n   #1 0x7f40c98688b1 in Exiv2::DataBuf::alloc(long) (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x4298b1)\\n   #2 0x541653 in (anonymous namespace)::metacopy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, bool) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x541653)\\n   #3 0x545049 in Action::Insert::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x545049)\\n   #4 0x4fddf3 in main (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4fddf3)\\n   #5 0x7f40c8ede1e1 in __libc_start_main /usr/src/debug/glibc-2.32-37-g760e1d2878/csu/../csu/libc-start.c:314:16\\nSUMMARY: AddressSanitizer: heap-buffer-overflow (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4c4d09) in __asan_memcpy\"\n        }\n      ],\n      \"vulnerability_details\": {\n        \"root_cause\": \"Integer overflow in `CrwMap::encode0x1810`.\",\n         \"weaknesses\": [\n           \"Integer overflow leading to heap-based buffer overflow.\"\n        ],\n        \"impact\": \"Denial of service (DoS) or potential arbitrary code execution.\",\n        \"attack_vectors\": [\n          \"Processing a malformed image file using the `exiv2 in` command.\",\n          \"Potentially processing a single crafted image file.\"\n        ],\n        \"attacker_capabilities\": \"Ability to craft a malicious image file containing specific metadata. \"\n      }\n    }\n  }\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |\n| 2 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |\n| 3 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.269 |\n| 4 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.247 |\n| 5 | 126 | Buffer Over-read | Variant | Allowed | sparse | 0.235 |\n| 6 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | dense | 0.612 |\n| 7 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |\n| 8 | 197 | Numeric Truncation Error | Base | Allowed | sparse | 0.233 |\n| 9 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.232 |\n| 10 | 130 | Improper Handling of Length Parameter Inconsistency | Base | Allowed | sparse | 0.224 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nBuffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean \"write past the end of a buffer,\" whereas others use the same term to mean \"any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer.\" Others could mean \"any action after the end of a buffer, whether it is a read or write.\" Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.\nbuffer overrun: Some prominent vendors and researchers use the term \"buffer overrun,\" but most people use \"buffer overflow.\" See the alternate term for \"buffer overflow\" for context.\nmemory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the \"memory safety\" term.\n\n### Relationships\nChildOf -> CWE-118\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.\n**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nIt is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.\n\n\n\n\n### Observed Examples\n- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.\n- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n\n\n\n## CWE-193: Off-by-one Error\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\noff-by-five: An \"off-by-five\" error was reported for sudo in 2002 (CVE-2002-0184), but that is more like a \"length calculation\" error.\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nCanPrecede -> CWE-617\nCanPrecede -> CWE-170\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is not always a buffer overflow. For example, an off-by-one error could be a factor in a partial comparison, a read from the wrong memory location, an incorrect conditional, etc.\n\n\n\n### Observed Examples\n- **CVE-2003-0252:** Off-by-one error allows remote attackers to cause a denial of service and possibly execute arbitrary code via requests that do not contain newlines.\n- **CVE-2001-1391:** Off-by-one vulnerability in driver allows users to modify kernel memory.\n- **CVE-2002-0083:** Off-by-one error allows local users or remote malicious servers to gain privileges.\n\n\n\n\n## CWE-126: Buffer Over-read\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.\n\n### Extended Description\nThis typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-125\nChildOf -> CWE-788\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** These problems may be resultant from missing sentinel values (CWE-463) or trusting a user-influenced input length variable.\n\n\n\n### Observed Examples\n- **CVE-2022-1733:** Text editor has out-of-bounds read past end of line while indenting C code\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated, leading to buffer over-read or heap-based buffer overflow.\n\n\n\n\n## CWE-789: Memory Allocation with Excessive Size Value\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.\n\n### Relationships\nChildOf -> CWE-770\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.\n\n**[Applicable Platform]** \n\nUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\n\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2010-3701:** program uses ::alloca() for encoding messages, but large messages trigger segfault\n- **CVE-2008-1708:** memory consumption and daemon exit by specifying a large value in a length field\n\n\n\n\n## CWE-128: Wrap-around Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nWrap around errors occur whenever a value is incremented past the maximum value for its type and therefore \"wraps around\" to a very small, negative, or undefined value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nCanPrecede -> CWE-119\nPeerOf -> CWE-190\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** The relationship between overflow and wrap-around needs to be examined more closely, since several entries (including CWE-190) are closely related.\n\n\n\n\n\n\n## CWE-197: Numeric Truncation Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTruncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.\n\n### Extended Description\nWhen a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-681\nChildOf -> CWE-681\nChildOf -> CWE-681\nCanAlsoBe -> CWE-195\nCanAlsoBe -> CWE-196\nCanAlsoBe -> CWE-192\nCanAlsoBe -> CWE-194\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** This weakness has traditionally been under-studied and under-reported, although vulnerabilities in popular software have been published in 2008 and 2009.\n\n\n\n### Observed Examples\n- **CVE-2020-17087:** Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.\n- **CVE-2009-0231:** Integer truncation of length value leads to heap-based buffer overflow.\n- **CVE-2008-3282:** Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n\n\n\n## CWE-130: Improper Handling of Length Parameter Inconsistency\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.\n\n### Extended Description\nIf an attacker can manipulate the length parameter associated with an input such that it is inconsistent with the actual length of the input, this can be leveraged to cause the target application to behave in unexpected, and possibly, malicious ways. One of the possible motives for doing so is to pass in arbitrarily large input to the application. Another possible motivation is the modification of application state by including invalid data for subsequent properties of the application. Such weaknesses commonly lead to attacks such as buffer overflows and execution of arbitrary code.\n\n### Alternative Terms\nlength manipulation\nlength tampering\n\n### Relationships\nChildOf -> CWE-240\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-805\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This probably overlaps other categories including zero-length issues.\n\n\n\n### Observed Examples\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n- **CVE-2009-2299:** Web application firewall consumes excessive memory when an HTTP request contains a large Content-Length value but no POST data.\n- **CVE-2001-0825:** Buffer overflow in internal string handling routine allows remote attackers to execute arbitrary commands via a length argument of zero or less, which disables the length check.\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\nAn **integer overflow** in CrwMapencode0x1810 of Exiv2 0.27.3 allows attackers to trigger a **heap-based buffer overflow** and cause a denial of service (DOS) via crafted metadata.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **integer overflow**\n- **weakness:** **heap-based buffer overflow**\n- **impact:** denial of service\n- **vector:** crafted metadata\n- **attacker:** attackers\n- **product:** Exiv2\n- **version:** 0.27.3\n- **component:** CrwMapencode0x1810\n\n## CVE Reference Links Content Summary\n```\n{\n  \"guidelines\": \"1. First verify if the content relates to the CVE specified based on the official description\\n2. If the content does not relate to this CVE, respond with \\\"UNRELATED\\\"\\n3. If no useful vulnerability information is found, respond with \\\"NOINFO\\\" \\n4. For relevant content, extract:\\n   - Root cause of vulnerability\\n   - Weaknesses/vulnerabilities present\\n   - Impact of exploitation\\n   - Attack vectors\\n   - Required attacker capabilities/position\\n\\nAdditional instructions:\\n- Preserve original technical details and descriptions\\n- Remove unrelated content\\n- Translate non-English content to English\\n- Note if the content provides more detail than the official CVE description\",\n  \"response\": {\n    \"CVE-2021-31292\": {\n      \"description\": \"The provided content contains information about CVE-2021-31292, which is an integer overflow in CrwMap::encode0x1810 leading to a heap-based buffer overflow and DoS. \",\n      \"information\": [\n        {\n          \"source\": \"lists.fedoraproject.org_d7e66bda_20250114_230433.html\",\n          \"content\": \"CVE-2021-31292 mingw-exiv2: exiv2: Integer overflow in CrwMap:encode0x1810 leading to heap-based buffer overflow and DoS [fedora-all]\"\n        },\n        {\n           \"source\": \"www.debian.org_d3f369e7_20250114_230436.html\",\n           \"content\": \"CVE ID : CVE-2019-20421 CVE-2021-3482 CVE-2021-29457 CVE-2021-29473 CVE-2021-31292 Several vulnerabilities have been discovered in Exiv2, a C++ library and a command line utility to manage image metadata which could result in denial of service or the execution of arbitrary code if a malformed file is parsed.\"\n         },\n        {\n          \"source\": \"security.gentoo.org_6f56c49b_20250114_230435.html\",\n          \"content\": \"* [CVE-2021-31292](https://nvd.nist.gov/vuln/detail/CVE-2021-31292)\"\n        },\n        {\n           \"source\": \"lists.fedoraproject.org_718fdc19_20250114_230434.html\",\n           \"content\": \"CVE-2021-31292 mingw-exiv2: exiv2: Integer overflow in CrwMap:encode0x1810 leading to heap-based buffer overflow and DoS [fedora-all]\"\n         },\n        {\n          \"source\": \"lists.debian.org_a624310b_20250114_230431.html\",\n           \"content\": \"CVE ID         : CVE-2019-20421 CVE-2021-3482 CVE-2021-29457 CVE-2021-29473 CVE-2021-31291 CVE-2021-31292\\nSeveral vulnerabilities have been discovered in Exiv2, a C++ library and a command line utility to manage image metadata which could result in denial of service or the execution of arbitrary code if a malformed file is parsed.\"\n         },\n        {\n          \"source\": \"github.com_4808aacc_20250114_230430.html\",\n          \"content\": \"heap-buffer-overflow Read in Exiv2::Internal::CrwMap::encode #1530\\n\\nVERSION exiv 2 0.27.4.1 \\n\\nREPRODUCE Compile exiv2 with asan:\\n\\nCC=clang CXX=clang++ cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS=\\\"-fsanitize=address\\\" \\\\\\n-DCMAKE_C_FLAGS=\\\"-fsanitize=address\\\" -DCMAKE_EXE_LINKER_FLAGS=\\\"-fsanitize=address\\\" \\\\\\n-DCMAKE_MODULE_LINKER_FLAGS=\\\"-fsanitize=address\\\"\\n\\nDowload testcases:\\n\\nhttps://github.com/henices/pocs/raw/master/tests_1bd0a5f4935b053f33ac00f931dde1f47a043487 https://github.com/henices/pocs/raw/master/tests_1bd0a5f4935b053f33ac00f931dde1f47a043487.exv\\n\\nRun command: `exiv2 in tests_1bd0a5f4935b053f33ac00f931dde1f47a043487`\\n\\n=================================================================\\n==119384==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62600000585e at pc 0x0000004c4d0a bp 0x7ffef1036370 sp 0x7ffef1035b20\\nREAD of size 4294967293 at 0x62600000585e thread T0\\n   #0 0x4c4d09 in __asan_memcpy (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4c4d09)\\n   #1 0x7f40c9907d88 in Exiv2::Internal::CrwMap::encode0x1810(Exiv2::Image const&, Exiv2::Internal::CrwMapping const*, Exiv2::Internal::CiffHeader*) (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x4c8d88)\\n   #2 0x7f40c9911007 in Exiv2::Internal::CrwMap::encode(Exiv2::Internal::CiffHeader*, Exiv2::Image const&) (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x4d2007)\\n   #3 0x7f40c9769376 in Exiv2::CrwImage::writeMetadata() (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x32a376)\\n   #4 0x541653 in (anonymous namespace)::metacopy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, bool) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x541653)\\n   #5 0x545049 in Action::Insert::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x545049)\\n   #6 0x4fddf3 in main (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4fddf3)\\n   #7 0x7f40c8ede1e1 in __libc_start_main /usr/src/debug/glibc-2.32-37-g760e1d2878/csu/../csu/libc-start.c:314:16\\n   #8 0x4224cd in _start (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4224cd)\\n0x62600000585e is located 0 bytes to the right of 10078-byte region [0x626000003100,0x62600000585e) allocated by thread T0 here:\\n   #0 0x4fad47 in operator new[](unsigned long) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4fad47)\\n   #1 0x7f40c98688b1 in Exiv2::DataBuf::alloc(long) (/home/henices/tests/exiv2/build_asan/lib/libexiv2.so.27+0x4298b1)\\n   #2 0x541653 in (anonymous namespace)::metacopy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, bool) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x541653)\\n   #3 0x545049 in Action::Insert::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x545049)\\n   #4 0x4fddf3 in main (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4fddf3)\\n   #5 0x7f40c8ede1e1 in __libc_start_main /usr/src/debug/glibc-2.32-37-g760e1d2878/csu/../csu/libc-start.c:314:16\\nSUMMARY: AddressSanitizer: heap-buffer-overflow (/home/henices/tests/exiv2/build_asan/bin/exiv2+0x4c4d09) in __asan_memcpy\"\n        }\n      ],\n      \"vulnerability_details\": {\n        \"root_cause\": \"Integer overflow in `CrwMap::encode0x1810`.\",\n         \"weaknesses\": [\n           \"Integer overflow leading to heap-based buffer overflow.\"\n        ],\n        \"impact\": \"Denial of service (DoS) or potential arbitrary code execution.\",\n        \"attack_vectors\": [\n          \"Processing a malformed image file using the `exiv2 in` command.\",\n          \"Potentially processing a single crafted image file.\"\n        ],\n        \"attacker_capabilities\": \"Ability to craft a malicious image file containing specific metadata. \"\n      }\n    }\n  }\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |\n| 2 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |\n| 3 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.269 |\n| 4 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.247 |\n| 5 | 126 | Buffer Over-read | Variant | Allowed | sparse | 0.235 |\n| 6 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | dense | 0.612 |\n| 7 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |\n| 8 | 197 | Numeric Truncation Error | Base | Allowed | sparse | 0.233 |\n| 9 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.232 |\n| 10 | 130 | Improper Handling of Length Parameter Inconsistency | Base | Allowed | sparse | 0.224 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nBuffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean \"write past the end of a buffer,\" whereas others use the same term to mean \"any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer.\" Others could mean \"any action after the end of a buffer, whether it is a read or write.\" Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.\nbuffer overrun: Some prominent vendors and researchers use the term \"buffer overrun,\" but most people use \"buffer overflow.\" See the alternate term for \"buffer overflow\" for context.\nmemory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the \"memory safety\" term.\n\n### Relationships\nChildOf -> CWE-118\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.\n**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nIt is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.\n\n\n\n\n### Observed Examples\n- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.\n- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n\n\n\n## CWE-193: Off-by-one Error\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\noff-by-five: An \"off-by-five\" error was reported for sudo in 2002 (CVE-2002-0184), but that is more like a \"length calculation\" error.\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nCanPrecede -> CWE-617\nCanPrecede -> CWE-170\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is not always a buffer overflow. For example, an off-by-one error could be a factor in a partial comparison, a read from the wrong memory location, an incorrect conditional, etc.\n\n\n\n### Observed Examples\n- **CVE-2003-0252:** Off-by-one error allows remote attackers to cause a denial of service and possibly execute arbitrary code via requests that do not contain newlines.\n- **CVE-2001-1391:** Off-by-one vulnerability in driver allows users to modify kernel memory.\n- **CVE-2002-0083:** Off-by-one error allows local users or remote malicious servers to gain privileges.\n\n\n\n\n## CWE-126: Buffer Over-read\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.\n\n### Extended Description\nThis typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-125\nChildOf -> CWE-788\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** These problems may be resultant from missing sentinel values (CWE-463) or trusting a user-influenced input length variable.\n\n\n\n### Observed Examples\n- **CVE-2022-1733:** Text editor has out-of-bounds read past end of line while indenting C code\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated, leading to buffer over-read or heap-based buffer overflow.\n\n\n\n\n## CWE-789: Memory Allocation with Excessive Size Value\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.\n\n### Relationships\nChildOf -> CWE-770\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.\n\n**[Applicable Platform]** \n\nUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\n\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2010-3701:** program uses ::alloca() for encoding messages, but large messages trigger segfault\n- **CVE-2008-1708:** memory consumption and daemon exit by specifying a large value in a length field\n\n\n\n\n## CWE-128: Wrap-around Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nWrap around errors occur whenever a value is incremented past the maximum value for its type and therefore \"wraps around\" to a very small, negative, or undefined value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nCanPrecede -> CWE-119\nPeerOf -> CWE-190\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** The relationship between overflow and wrap-around needs to be examined more closely, since several entries (including CWE-190) are closely related.\n\n\n\n\n\n\n## CWE-197: Numeric Truncation Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTruncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.\n\n### Extended Description\nWhen a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-681\nChildOf -> CWE-681\nChildOf -> CWE-681\nCanAlsoBe -> CWE-195\nCanAlsoBe -> CWE-196\nCanAlsoBe -> CWE-192\nCanAlsoBe -> CWE-194\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** This weakness has traditionally been under-studied and under-reported, although vulnerabilities in popular software have been published in 2008 and 2009.\n\n\n\n### Observed Examples\n- **CVE-2020-17087:** Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.\n- **CVE-2009-0231:** Integer truncation of length value leads to heap-based buffer overflow.\n- **CVE-2008-3282:** Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n\n\n\n## CWE-130: Improper Handling of Length Parameter Inconsistency\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.\n\n### Extended Description\nIf an attacker can manipulate the length parameter associated with an input such that it is inconsistent with the actual length of the input, this can be leveraged to cause the target application to behave in unexpected, and possibly, malicious ways. One of the possible motives for doing so is to pass in arbitrarily large input to the application. Another possible motivation is the modification of application state by including invalid data for subsequent properties of the application. Such weaknesses commonly lead to attacks such as buffer overflows and execution of arbitrary code.\n\n### Alternative Terms\nlength manipulation\nlength tampering\n\n### Relationships\nChildOf -> CWE-240\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-805\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This probably overlaps other categories including zero-length issues.\n\n\n\n### Observed Examples\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n- **CVE-2009-2299:** Web application firewall consumes excessive memory when an HTTP request contains a large Content-Length value but no POST data.\n- **CVE-2001-0825:** Buffer overflow in internal string handling routine allows remote attackers to execute arbitrary commands via a length argument of zero or less, which disables the length check.\n\n"
  },
  "timestamp": "2025-04-02 08:04:32",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 7555.529741566798,
      "search_source": "unknown"
    },
    {
      "cwe_id": "197",
      "name": "Numeric Truncation Error",
      "score": 6944.5523777004955,
      "search_source": "unknown"
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 6919.275780977961,
      "search_source": "unknown"
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "score": 6799.32859290199,
      "search_source": "unknown"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 6787.924975666668,
      "search_source": "unknown"
    }
  ]
}