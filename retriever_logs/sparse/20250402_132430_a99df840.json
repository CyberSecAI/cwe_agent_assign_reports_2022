{
  "retriever": "sparse",
  "query": "## Vulnerability Description\nA flaw was found in the ptp4l program of the linuxptp package. When ptp4l is operating on a little-endian architecture as a PTP transparent clock, a remote attacker could send a crafted one-step sync message to cause an information leak or crash. The highest threat from this vulnerability is to data confidentiality and system availability. This flaw affects linuxptp versions before 3.1.1 and before 2.0.1.\n\n### Vulnerability Description Key Phrases\n- **impact:** information leak and crash\n- **vector:** crafted one-step sync message\n- **attacker:** remote attacker\n- **product:** linuxptp\n- **version:** before 3.1.1 and before 2.0.1\n- **component:** ptp4l program\n\n## CVE Reference Links Content Summary\n```\n{\n  \"CVE-2021-3571\": {\n    \"related_content\": [\n      {\n        \"source\": \"lists.fedoraproject.org_c6af6f4d_20250115_090906.html\",\n        \"url\": \"lists.fedoraproject.org_c6af6f4d_20250115_090906.html\",\n         \"vulnerability_details\": {\n          \"root_cause\": \"When `ptp4l` is operating on a little-endian architecture as a PTP transparent clock and forwards a one-step sync message, it generates a follow-up message with an incorrect length, sending data past the message buffer.\",\n          \"weaknesses\": [\n            \"Improper length calculation\",\n            \"Out-of-bounds write\"\n          ],\n          \"impact\": \"An attacker with access to the network can send a crafted one-step sync message to cause an information leak or crash.\",\n          \"attack_vectors\": [\n            \"Network-based attack\"\n          ],\n           \"required_attacker_capabilities\": \"Attacker needs network access and the ability to send PTP messages.\"\n        }\n      },\n      {\n         \"source\": \"bugzilla.redhat.com_1125de42_20250115_221315.html\",\n         \"url\": \"bugzilla.redhat.com_1125de42_20250115_221315.html\",\n         \"vulnerability_details\": {\n          \"root_cause\": \"When `ptp4l` operates as a PTP transparent clock on a little-endian architecture, it generates a follow-up message with an incorrect length when forwarding a one-step sync message, leading to an out-of-bounds write.\",\n          \"weaknesses\": [\n            \"Incorrect length calculation\",\n             \"Out-of-bounds write\"\n          ],\n          \"impact\": \"An attacker can send a crafted one-step sync message to cause an information leak or crash, potentially affecting data confidentiality and system availability.\",\n          \"attack_vectors\": [\n            \"Network-based attack\"\n          ],\n          \"required_attacker_capabilities\": \"An attacker with network access can send a one-step sync message to trigger the vulnerability. The target system must be a transparent clock running on a little-endian architecture.\"\n        }\n      },\n      {\n          \"source\": \"access.redhat.com_b29e222c_20250115_133837.html\",\n          \"url\": \"access.redhat.com_b29e222c_20250115_133837.html\",\n           \"vulnerability_details\": {\n            \"root_cause\": \"The vulnerability occurs due to a wrong length calculation of one-step follow-up messages in transparent clock mode of the `linuxptp` package.\",\n             \"weaknesses\": [\n               \"Improper length calculation\"\n             ],\n              \"impact\": \"A remote attacker could send a crafted one-step sync message to cause an information leak or crash.\",\n             \"attack_vectors\": [\n               \"Network-based attack\"\n             ],\n              \"required_attacker_capabilities\": \"Attacker requires network access.\"\n        }\n       },\n          {\n        \"source\": \"access.redhat.com_1dbe72d5_20250115_133837.html\",\n        \"url\":\"access.redhat.com_1dbe72d5_20250115_133837.html\",\n        \"vulnerability_details\": {\n          \"root_cause\": \"The linuxptp package had a flaw where the length of a one-step follow-up message in a transparent clock was calculated incorrectly.\",\n          \"weaknesses\":[\n            \"Improper length calculation\"\n          ],\n           \"impact\": \"A remote attacker can exploit this by sending a crafted message that causes an information leak or crash on a vulnerable system.\",\n          \"attack_vectors\": [\n            \"Network-based attack\"\n          ],\n           \"required_attacker_capabilities\": \"The attacker requires network access to send specifically crafted PTP messages.\"\n        }\n      },\n       {\n        \"source\": \"lists.fedoraproject.org_36d4d1ef_20250115_090906.html\",\n         \"url\": \"lists.fedoraproject.org_36d4d1ef_20250115_090906.html\",\n         \"vulnerability_details\": {\n            \"root_cause\": \"The vulnerability exists in the processing of one-step follow-up messages in `linuxptp`, where an incorrect length calculation can cause an out-of-bounds write.\",\n           \"weaknesses\": [\n            \"Improper length calculation\",\n            \"Out-of-bounds write\"\n          ],\n            \"impact\": \"A remote attacker with network access can send a crafted PTP message that causes information disclosure or a crash.\",\n            \"attack_vectors\": [\n              \"Network-based attack\"\n            ],\n            \"required_attacker_capabilities\": \"Attacker requires network access to send PTP packets.\"\n        }\n      },\n           {\n          \"source\": \"access.redhat.com_771843d1_20250115_221311.html\",\n          \"url\":\"access.redhat.com_771843d1_20250115_221311.html\",\n            \"vulnerability_details\": {\n               \"root_cause\": \"The description points to an issue related to wrong length of one-step follow-up in transparent clock mode.\",\n               \"weaknesses\": [\n                 \"Improper length calculation\"\n              ],\n              \"impact\": \"A remote attacker could send a crafted one-step sync message to cause an information leak or crash.\",\n               \"attack_vectors\": [\n                  \"Network-based attack\"\n               ],\n               \"required_attacker_capabilities\": \"Attacker requires network access to send PTP messages\"\n          }\n       },\n       {\n         \"source\": \"access.redhat.com_4c3802ee_20250115_221312.html\",\n         \"url\": \"access.redhat.com_4c3802ee_20250115_221312.html\",\n         \"vulnerability_details\": {\n           \"root_cause\": \"The vulnerability stems from the incorrect handling of one-step follow-up messages in transparent clock mode. The program calculates message lengths improperly, causing it to potentially write beyond buffer boundaries.\",\n           \"weaknesses\": [\n             \"Improper length calculation\",\n             \"Out-of-bounds write\"\n           ],\n           \"impact\": \"A remote attacker can send crafted one-step sync messages to induce an information leak or cause a system crash.\",\n            \"attack_vectors\": [\n              \"Network-based attack\"\n            ],\n            \"required_attacker_capabilities\": \"The attacker needs network access and the ability to send specifically crafted PTP messages to trigger the vulnerability.\"\n         }\n       },\n       {\n          \"source\": \"access.redhat.com_17465dfb_20250115_221313.html\",\n          \"url\": \"access.redhat.com_17465dfb_20250115_221313.html\",\n          \"vulnerability_details\": {\n             \"root_cause\": \"This document describes Red Hat's severity ratings for security flaws but doesn't discuss the specific root cause of CVE-2021-3571, other than mentioning the CVSS scoring system.\",\n            \"weaknesses\": [\n             \"Not applicable (general information)\"\n            ],\n             \"impact\": \"Not applicable (general information)\",\n             \"attack_vectors\": [\n              \"Not applicable (general information)\"\n              ],\n             \"required_attacker_capabilities\": \"Not applicable (general information)\"\n          }\n       },\n        {\n          \"source\": \"access.redhat.com_7756f625_20250115_133839.html\",\n          \"url\": \"access.redhat.com_7756f625_20250115_133839.html\",\n           \"vulnerability_details\": {\n            \"root_cause\": \"This content is related to Red Hat login and does not contain any details related to CVE-2021-3571.\",\n             \"weaknesses\": [\n              \"UNRELATED\"\n            ],\n             \"impact\": \"UNRELATED\",\n             \"attack_vectors\": [\n               \"UNRELATED\"\n             ],\n            \"required_attacker_capabilities\":\"UNRELATED\"\n            }\n        },\n         {\n          \"source\": \"pagure.io_edb6cad0_20250115_221307.html\",\n           \"url\": \"pagure.io_edb6cad0_20250115_221307.html\",\n            \"vulnerability_details\": {\n            \"root_cause\": \"This content is related to a discussion about a mass rebuild of packages to update systemd scriptlets and does not contain details on CVE-2021-3571.\",\n              \"weaknesses\": [\n                  \"UNRELATED\"\n              ],\n             \"impact\": \"UNRELATED\",\n              \"attack_vectors\": [\n                  \"UNRELATED\"\n              ],\n              \"required_attacker_capabilities\": \"UNRELATED\"\n           }\n        }\n    ]\n  }\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.158 |\n| 2 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.129 |\n| 3 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.126 |\n| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.125 |\n| 5 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.124 |\n| 6 | 121 | Stack-based Buffer Overflow | Variant | Allowed | dense | 0.512 |\n| 7 | 823 | Use of Out-of-range Pointer Offset | Base | Allowed | graph | 0.003 |\n| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.123 |\n| 9 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 0.123 |\n| 10 | 824 | Access of Uninitialized Pointer | Base | Allowed | sparse | 0.123 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-401: Missing Release of Memory after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.\n\n### Extended Description\nThis is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.\n\n### Alternative Terms\nMemory Leak\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is often a resultant weakness due to improper handling of malformed data or early termination of sessions.\n\n**[Terminology]** \"memory leak\" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict).\n\n\n\n### Observed Examples\n- **CVE-2005-3119:** Memory leak because function does not free() an element of a data structure.\n- **CVE-2004-0427:** Memory leak when counter variable is not decremented.\n- **CVE-2002-0574:** chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.\n\n\n\n\n## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nBuffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean \"write past the end of a buffer,\" whereas others use the same term to mean \"any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer.\" Others could mean \"any action after the end of a buffer, whether it is a read or write.\" Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.\nbuffer overrun: Some prominent vendors and researchers use the term \"buffer overrun,\" but most people use \"buffer overflow.\" See the alternate term for \"buffer overflow\" for context.\nmemory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the \"memory safety\" term.\n\n### Relationships\nChildOf -> CWE-118\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.\n**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nIt is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.\n\n\n\n\n### Observed Examples\n- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.\n- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n\n\n\n## CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently.\n\n### Extended Description\n\n\nA race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.\n\n\nA race condition violates these properties, which are closely related:\n\n\n  - Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.\n\n  - Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource.\n\nA race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity.\n\nThe interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.\n\n\n### Alternative Terms\nRace Condition\n\n### Relationships\nChildOf -> CWE-691\nCanPrecede -> CWE-416\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** The relationship between race conditions and synchronization problems (CWE-662) needs to be further developed. They are not necessarily two perspectives of the same core concept, since synchronization is only one technique for avoiding race conditions, and synchronization can be used for other purposes besides race condition prevention.\n\n**[Research Gap]** Race conditions in web applications are under-studied and probably under-reported. However, in 2008 there has been growing interest in this area.\n\n**[Research Gap]** Much of the focus of race condition research has been in Time-of-check Time-of-use (TOCTOU) variants (CWE-367), but many race conditions are related to synchronization problems that do not necessarily require a time-of-check.\n\n**[Research Gap]** From a classification/taxonomy perspective, the relationships between concurrency and program state need closer investigation and may be useful in organizing related issues.\n\n\n\n### Observed Examples\n- **CVE-2022-29527:** Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.\n- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.\n- **CVE-2021-0920:** Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-789: Memory Allocation with Excessive Size Value\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.\n\n### Relationships\nChildOf -> CWE-770\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.\n\n**[Applicable Platform]** \n\nUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\n\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2010-3701:** program uses ::alloca() for encoding messages, but large messages trigger segfault\n- **CVE-2008-1708:** memory consumption and daemon exit by specifying a large value in a length field\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-823: Use of Out-of-range Pointer Offset\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.\n\n### Extended Description\n\n\nWhile a pointer can contain a reference to any arbitrary memory location, a program typically only intends to use the pointer to access limited portions of memory, such as contiguous memory used to access an individual array.\n\n\nPrograms may use offsets in order to access fields or sub-elements stored within structured data. The offset might be out-of-range if it comes from an untrusted source, is the result of an incorrect calculation, or occurs because of another error.\n\n\nIf an attacker can control or influence the offset so that it points outside of the intended boundaries of the structure, then the attacker may be able to read or write to memory locations that are used elsewhere in the product. As a result, the attack might change the state of the product as accessed through program variables, cause a crash or instable behavior, and possibly lead to code execution.\n\n\n### Alternative Terms\nUntrusted pointer offset: This term is narrower than the concept of \"out-of-range\" offset, since the offset might be the result of a calculation or other error that does not depend on any externally-supplied values.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-125\nCanPrecede -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.\n\n**[Terminology]** Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants.\n\n\n\n### Observed Examples\n- **CVE-2010-2160:** Invalid offset in undocumented opcode leads to memory corruption.\n- **CVE-2010-1281:** Multimedia player uses untrusted value from a file when using file-pointer calculations.\n- **CVE-2009-3129:** Spreadsheet program processes a record with an invalid size field, which is later used as an offset.\n\n\n\n\n## CWE-674: Uncontrolled Recursion\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion\n\n### Relationships\nChildOf -> CWE-834\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2007-1285:** Deeply nested arrays trigger stack exhaustion.\n- **CVE-2007-3409:** Self-referencing pointers create infinite loop and resultant stack exhaustion.\n- **CVE-2016-10707:** Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.\n\n\n\n\n## CWE-754: Improper Check for Unusual or Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.\n\n### Extended Description\n\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\nCanPrecede -> CWE-416\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.\n- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.\n\n\n\n\n## CWE-824: Access of Uninitialized Pointer\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product accesses or uses a pointer that has not been initialized.\n\n### Extended Description\n\n\nIf the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the product to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks.\n\n\nDepending on memory layout, associated memory management behaviors, and product operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more fine-grained control of the memory location to be accessed.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-125\nCanPrecede -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.\n\n**[Terminology]** Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants.\n\n\n\n### Observed Examples\n- **CVE-2024-32878:** LLM product has a free of an uninitialized pointer\n- **CVE-2010-0211:** chain: unchecked return value (CWE-252) leads to free of invalid, uninitialized pointer (CWE-824).\n- **CVE-2009-2768:** Pointer in structure is not initialized, leading to NULL pointer dereference (CWE-476) and system crash.\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\nA flaw was found in the ptp4l program of the linuxptp package. When ptp4l is operating on a little-endian architecture as a PTP transparent clock, a remote attacker could send a crafted one-step sync message to cause an information leak or crash. The highest threat from this vulnerability is to data confidentiality and system availability. This flaw affects linuxptp versions before 3.1.1 and before 2.0.1.\n\n### Vulnerability Description Key Phrases\n- **impact:** information leak and crash\n- **vector:** crafted one-step sync message\n- **attacker:** remote attacker\n- **product:** linuxptp\n- **version:** before 3.1.1 and before 2.0.1\n- **component:** ptp4l program\n\n## CVE Reference Links Content Summary\n```\n{\n  \"CVE-2021-3571\": {\n    \"related_content\": [\n      {\n        \"source\": \"lists.fedoraproject.org_c6af6f4d_20250115_090906.html\",\n        \"url\": \"lists.fedoraproject.org_c6af6f4d_20250115_090906.html\",\n         \"vulnerability_details\": {\n          \"root_cause\": \"When `ptp4l` is operating on a little-endian architecture as a PTP transparent clock and forwards a one-step sync message, it generates a follow-up message with an incorrect length, sending data past the message buffer.\",\n          \"weaknesses\": [\n            \"Improper length calculation\",\n            \"Out-of-bounds write\"\n          ],\n          \"impact\": \"An attacker with access to the network can send a crafted one-step sync message to cause an information leak or crash.\",\n          \"attack_vectors\": [\n            \"Network-based attack\"\n          ],\n           \"required_attacker_capabilities\": \"Attacker needs network access and the ability to send PTP messages.\"\n        }\n      },\n      {\n         \"source\": \"bugzilla.redhat.com_1125de42_20250115_221315.html\",\n         \"url\": \"bugzilla.redhat.com_1125de42_20250115_221315.html\",\n         \"vulnerability_details\": {\n          \"root_cause\": \"When `ptp4l` operates as a PTP transparent clock on a little-endian architecture, it generates a follow-up message with an incorrect length when forwarding a one-step sync message, leading to an out-of-bounds write.\",\n          \"weaknesses\": [\n            \"Incorrect length calculation\",\n             \"Out-of-bounds write\"\n          ],\n          \"impact\": \"An attacker can send a crafted one-step sync message to cause an information leak or crash, potentially affecting data confidentiality and system availability.\",\n          \"attack_vectors\": [\n            \"Network-based attack\"\n          ],\n          \"required_attacker_capabilities\": \"An attacker with network access can send a one-step sync message to trigger the vulnerability. The target system must be a transparent clock running on a little-endian architecture.\"\n        }\n      },\n      {\n          \"source\": \"access.redhat.com_b29e222c_20250115_133837.html\",\n          \"url\": \"access.redhat.com_b29e222c_20250115_133837.html\",\n           \"vulnerability_details\": {\n            \"root_cause\": \"The vulnerability occurs due to a wrong length calculation of one-step follow-up messages in transparent clock mode of the `linuxptp` package.\",\n             \"weaknesses\": [\n               \"Improper length calculation\"\n             ],\n              \"impact\": \"A remote attacker could send a crafted one-step sync message to cause an information leak or crash.\",\n             \"attack_vectors\": [\n               \"Network-based attack\"\n             ],\n              \"required_attacker_capabilities\": \"Attacker requires network access.\"\n        }\n       },\n          {\n        \"source\": \"access.redhat.com_1dbe72d5_20250115_133837.html\",\n        \"url\":\"access.redhat.com_1dbe72d5_20250115_133837.html\",\n        \"vulnerability_details\": {\n          \"root_cause\": \"The linuxptp package had a flaw where the length of a one-step follow-up message in a transparent clock was calculated incorrectly.\",\n          \"weaknesses\":[\n            \"Improper length calculation\"\n          ],\n           \"impact\": \"A remote attacker can exploit this by sending a crafted message that causes an information leak or crash on a vulnerable system.\",\n          \"attack_vectors\": [\n            \"Network-based attack\"\n          ],\n           \"required_attacker_capabilities\": \"The attacker requires network access to send specifically crafted PTP messages.\"\n        }\n      },\n       {\n        \"source\": \"lists.fedoraproject.org_36d4d1ef_20250115_090906.html\",\n         \"url\": \"lists.fedoraproject.org_36d4d1ef_20250115_090906.html\",\n         \"vulnerability_details\": {\n            \"root_cause\": \"The vulnerability exists in the processing of one-step follow-up messages in `linuxptp`, where an incorrect length calculation can cause an out-of-bounds write.\",\n           \"weaknesses\": [\n            \"Improper length calculation\",\n            \"Out-of-bounds write\"\n          ],\n            \"impact\": \"A remote attacker with network access can send a crafted PTP message that causes information disclosure or a crash.\",\n            \"attack_vectors\": [\n              \"Network-based attack\"\n            ],\n            \"required_attacker_capabilities\": \"Attacker requires network access to send PTP packets.\"\n        }\n      },\n           {\n          \"source\": \"access.redhat.com_771843d1_20250115_221311.html\",\n          \"url\":\"access.redhat.com_771843d1_20250115_221311.html\",\n            \"vulnerability_details\": {\n               \"root_cause\": \"The description points to an issue related to wrong length of one-step follow-up in transparent clock mode.\",\n               \"weaknesses\": [\n                 \"Improper length calculation\"\n              ],\n              \"impact\": \"A remote attacker could send a crafted one-step sync message to cause an information leak or crash.\",\n               \"attack_vectors\": [\n                  \"Network-based attack\"\n               ],\n               \"required_attacker_capabilities\": \"Attacker requires network access to send PTP messages\"\n          }\n       },\n       {\n         \"source\": \"access.redhat.com_4c3802ee_20250115_221312.html\",\n         \"url\": \"access.redhat.com_4c3802ee_20250115_221312.html\",\n         \"vulnerability_details\": {\n           \"root_cause\": \"The vulnerability stems from the incorrect handling of one-step follow-up messages in transparent clock mode. The program calculates message lengths improperly, causing it to potentially write beyond buffer boundaries.\",\n           \"weaknesses\": [\n             \"Improper length calculation\",\n             \"Out-of-bounds write\"\n           ],\n           \"impact\": \"A remote attacker can send crafted one-step sync messages to induce an information leak or cause a system crash.\",\n            \"attack_vectors\": [\n              \"Network-based attack\"\n            ],\n            \"required_attacker_capabilities\": \"The attacker needs network access and the ability to send specifically crafted PTP messages to trigger the vulnerability.\"\n         }\n       },\n       {\n          \"source\": \"access.redhat.com_17465dfb_20250115_221313.html\",\n          \"url\": \"access.redhat.com_17465dfb_20250115_221313.html\",\n          \"vulnerability_details\": {\n             \"root_cause\": \"This document describes Red Hat's severity ratings for security flaws but doesn't discuss the specific root cause of CVE-2021-3571, other than mentioning the CVSS scoring system.\",\n            \"weaknesses\": [\n             \"Not applicable (general information)\"\n            ],\n             \"impact\": \"Not applicable (general information)\",\n             \"attack_vectors\": [\n              \"Not applicable (general information)\"\n              ],\n             \"required_attacker_capabilities\": \"Not applicable (general information)\"\n          }\n       },\n        {\n          \"source\": \"access.redhat.com_7756f625_20250115_133839.html\",\n          \"url\": \"access.redhat.com_7756f625_20250115_133839.html\",\n           \"vulnerability_details\": {\n            \"root_cause\": \"This content is related to Red Hat login and does not contain any details related to CVE-2021-3571.\",\n             \"weaknesses\": [\n              \"UNRELATED\"\n            ],\n             \"impact\": \"UNRELATED\",\n             \"attack_vectors\": [\n               \"UNRELATED\"\n             ],\n            \"required_attacker_capabilities\":\"UNRELATED\"\n            }\n        },\n         {\n          \"source\": \"pagure.io_edb6cad0_20250115_221307.html\",\n           \"url\": \"pagure.io_edb6cad0_20250115_221307.html\",\n            \"vulnerability_details\": {\n            \"root_cause\": \"This content is related to a discussion about a mass rebuild of packages to update systemd scriptlets and does not contain details on CVE-2021-3571.\",\n              \"weaknesses\": [\n                  \"UNRELATED\"\n              ],\n             \"impact\": \"UNRELATED\",\n              \"attack_vectors\": [\n                  \"UNRELATED\"\n              ],\n              \"required_attacker_capabilities\": \"UNRELATED\"\n           }\n        }\n    ]\n  }\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.158 |\n| 2 | 401 | Missing Release of Memory after Effective Lifetime | Variant | Allowed | sparse | 0.129 |\n| 3 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | sparse | 0.126 |\n| 4 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.125 |\n| 5 | 789 | Memory Allocation with Excessive Size Value | Variant | Allowed | sparse | 0.124 |\n| 6 | 121 | Stack-based Buffer Overflow | Variant | Allowed | dense | 0.512 |\n| 7 | 823 | Use of Out-of-range Pointer Offset | Base | Allowed | graph | 0.003 |\n| 8 | 674 | Uncontrolled Recursion | Class | Allowed-with-Review | sparse | 0.123 |\n| 9 | 754 | Improper Check for Unusual or Exceptional Conditions | Class | Allowed-with-Review | sparse | 0.123 |\n| 10 | 824 | Access of Uninitialized Pointer | Base | Allowed | sparse | 0.123 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-401: Missing Release of Memory after Effective Lifetime\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.\n\n### Extended Description\nThis is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.\n\n### Alternative Terms\nMemory Leak\n\n### Relationships\nChildOf -> CWE-772\nChildOf -> CWE-404\nChildOf -> CWE-404\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is often a resultant weakness due to improper handling of malformed data or early termination of sessions.\n\n**[Terminology]** \"memory leak\" has sometimes been used to describe other kinds of issues, e.g. for information leaks in which the contents of memory are inadvertently leaked (CVE-2003-0400 is one such example of this terminology conflict).\n\n\n\n### Observed Examples\n- **CVE-2005-3119:** Memory leak because function does not free() an element of a data structure.\n- **CVE-2004-0427:** Memory leak when counter variable is not decremented.\n- **CVE-2002-0574:** chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.\n\n\n\n\n## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nBuffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean \"write past the end of a buffer,\" whereas others use the same term to mean \"any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer.\" Others could mean \"any action after the end of a buffer, whether it is a read or write.\" Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.\nbuffer overrun: Some prominent vendors and researchers use the term \"buffer overrun,\" but most people use \"buffer overflow.\" See the alternate term for \"buffer overflow\" for context.\nmemory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the \"memory safety\" term.\n\n### Relationships\nChildOf -> CWE-118\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.\n**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nIt is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.\n\n\n\n\n### Observed Examples\n- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.\n- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n\n\n\n## CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently.\n\n### Extended Description\n\n\nA race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.\n\n\nA race condition violates these properties, which are closely related:\n\n\n  - Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.\n\n  - Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource.\n\nA race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity.\n\nThe interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.\n\n\n### Alternative Terms\nRace Condition\n\n### Relationships\nChildOf -> CWE-691\nCanPrecede -> CWE-416\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** The relationship between race conditions and synchronization problems (CWE-662) needs to be further developed. They are not necessarily two perspectives of the same core concept, since synchronization is only one technique for avoiding race conditions, and synchronization can be used for other purposes besides race condition prevention.\n\n**[Research Gap]** Race conditions in web applications are under-studied and probably under-reported. However, in 2008 there has been growing interest in this area.\n\n**[Research Gap]** Much of the focus of race condition research has been in Time-of-check Time-of-use (TOCTOU) variants (CWE-367), but many race conditions are related to synchronization problems that do not necessarily require a time-of-check.\n\n**[Research Gap]** From a classification/taxonomy perspective, the relationships between concurrency and program state need closer investigation and may be useful in organizing related issues.\n\n\n\n### Observed Examples\n- **CVE-2022-29527:** Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.\n- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.\n- **CVE-2021-0920:** Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-789: Memory Allocation with Excessive Size Value\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion: When a weakness allocates excessive memory on the stack, it is often described as \"stack exhaustion,\" which is a technical impact of the weakness. This technical impact is often encountered as a consequence of CWE-789 and/or CWE-1325.\n\n### Relationships\nChildOf -> CWE-770\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This weakness can be closely associated with integer overflows (CWE-190). Integer overflow attacks would concentrate on providing an extremely large number that triggers an overflow that causes less memory to be allocated than expected. By providing a large value that does not trigger an integer overflow, the attacker could still cause excessive amounts of memory to be allocated.\n\n**[Applicable Platform]** \n\nUncontrolled memory allocation is possible in many languages, such as dynamic array allocation in perl or initial size parameters in Collections in Java. However, languages like C and C++ where programmers have the power to more directly control memory management will be more susceptible.\n\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2010-3701:** program uses ::alloca() for encoding messages, but large messages trigger segfault\n- **CVE-2008-1708:** memory consumption and daemon exit by specifying a large value in a length field\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-823: Use of Out-of-range Pointer Offset\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.\n\n### Extended Description\n\n\nWhile a pointer can contain a reference to any arbitrary memory location, a program typically only intends to use the pointer to access limited portions of memory, such as contiguous memory used to access an individual array.\n\n\nPrograms may use offsets in order to access fields or sub-elements stored within structured data. The offset might be out-of-range if it comes from an untrusted source, is the result of an incorrect calculation, or occurs because of another error.\n\n\nIf an attacker can control or influence the offset so that it points outside of the intended boundaries of the structure, then the attacker may be able to read or write to memory locations that are used elsewhere in the product. As a result, the attack might change the state of the product as accessed through program variables, cause a crash or instable behavior, and possibly lead to code execution.\n\n\n### Alternative Terms\nUntrusted pointer offset: This term is narrower than the concept of \"out-of-range\" offset, since the offset might be the result of a calculation or other error that does not depend on any externally-supplied values.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-125\nCanPrecede -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.\n\n**[Terminology]** Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants.\n\n\n\n### Observed Examples\n- **CVE-2010-2160:** Invalid offset in undocumented opcode leads to memory corruption.\n- **CVE-2010-1281:** Multimedia player uses untrusted value from a file when using file-pointer calculations.\n- **CVE-2009-3129:** Spreadsheet program processes a record with an invalid size field, which is later used as an offset.\n\n\n\n\n## CWE-674: Uncontrolled Recursion\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly control the amount of recursion that takes place,  consuming excessive resources, such as allocated memory or the program stack.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Exhaustion\n\n### Relationships\nChildOf -> CWE-834\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2007-1285:** Deeply nested arrays trigger stack exhaustion.\n- **CVE-2007-3409:** Self-referencing pointers create infinite loop and resultant stack exhaustion.\n- **CVE-2016-10707:** Javascript application accidentally changes input in a way that prevents a recursive call from detecting an exit condition.\n\n\n\n\n## CWE-754: Improper Check for Unusual or Exceptional Conditions\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not check or incorrectly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the product.\n\n### Extended Description\n\n\nThe programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.\n\n\nNote that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-703\nCanPrecede -> CWE-416\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** Sometimes, when a return value can be used to indicate an error, an unchecked return value is a code-layer instance of a missing application-layer check for exceptional conditions. However, return values are not always needed to communicate exceptional conditions. For example, expiration of resources, values passed by reference, asynchronously modified data, sockets, etc. may indicate exceptional conditions without the use of a return value.\n\n\n\n### Observed Examples\n- **CVE-2023-49286:** Chain: function in web caching proxy does not correctly check a return value (CWE-253) leading to a reachable assertion (CWE-617)\n- **CVE-2007-3798:** Unchecked return value leads to resultant integer overflow and code execution.\n- **CVE-2006-4447:** Program does not check return value when invoking functions to drop privileges, which could leave users with higher privileges than expected by forcing those functions to fail.\n\n\n\n\n## CWE-824: Access of Uninitialized Pointer\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product accesses or uses a pointer that has not been initialized.\n\n### Extended Description\n\n\nIf the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the product to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks.\n\n\nDepending on memory layout, associated memory management behaviors, and product operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more fine-grained control of the memory location to be accessed.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nCanPrecede -> CWE-125\nCanPrecede -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.\n\n**[Terminology]** Many weaknesses related to pointer dereferences fall under the general term of \"memory corruption\" or \"memory safety.\" As of September 2010, there is no commonly-used terminology that covers the lower-level variants.\n\n\n\n### Observed Examples\n- **CVE-2024-32878:** LLM product has a free of an uninitialized pointer\n- **CVE-2010-0211:** chain: unchecked return value (CWE-252) leads to free of invalid, uninitialized pointer (CWE-824).\n- **CVE-2009-2768:** Pointer in structure is not initialized, leading to NULL pointer dereference (CWE-476) and system crash.\n\n"
  },
  "timestamp": "2025-04-02 13:24:30",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "score": 7170.295591449049,
      "search_source": "unknown"
    },
    {
      "cwe_id": "823",
      "name": "Use of Out-of-range Pointer Offset",
      "score": 6892.105587267779,
      "search_source": "unknown"
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "score": 6844.5480801248805,
      "search_source": "unknown"
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "score": 6815.082918918617,
      "search_source": "unknown"
    },
    {
      "cwe_id": "1284",
      "name": "Improper Validation of Specified Quantity in Input",
      "score": 6788.430700662275,
      "search_source": "unknown"
    }
  ]
}