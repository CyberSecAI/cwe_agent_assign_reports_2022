{
  "retriever": "sparse",
  "query": "## Vulnerability Description\nIn change_pte_range of mprotect.c , there is a possible way to make a shared mmap writable due to a **permissions bypass**. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product AndroidVersions Android kernelAndroid ID A-213339151References Upstream kernel\n\n### Vulnerability Description Key Phrases\n- **weakness:** **permissions bypass**\n- **impact:** make shared mmap writable\n- **product:** Android\n- **component:** change_pte_range of mprotect.c\n\n## CVE Reference Links Content Summary\n```\n{\n  \"CVE-2021-39802\": {\n    \"related_content\": [\n      {\n        \"type\": \"commit message\",\n        \"content\": \"In the Scudo memory allocator [1] we would like to be able to detect use-after-free vulnerabilities involving large allocations by issuing mprotect(PROT_NONE) on the memory region used for the allocation when it is deallocated. Later on, after the memory region has been \\\"quarantined\\\" for a sufficient period of time we would like to be able to use it for another allocation by issuing mprotect(PROT_READ|PROT_WRITE).\\n\\nBefore this patch, after removing the write protection, any writes to the memory region would result in page faults and entering the copy-on-write code path, even in the usual case where the pages are only referenced by a single PTE, harming performance unnecessarily. Make it so that any pages in anonymous mappings that are only referenced by a single PTE are immediately made writable during the mprotect so that we can avoid the page faults.\\n\\nThis program shows the critical syscall sequence that we intend to use in the allocator:\\n\\n  #include <string.h>\\n  #include <sys/mman.h>\\n\\n  enum { kSize = 131072 };\\n\\n  int main(int argc, char **argv) {\\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\\n    for (int i = 0; i != 100000; ++i) {\\n      memset(addr, i, kSize);\\n      mprotect((void *)addr, kSize, PROT_NONE);\\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\\n    }\\n  }\\n\\nThe effect of this patch on the above program was measured on a\\nDragonBoard 845c by taking the median real time execution time of 10 runs.\\n\\nBefore: 2.94s\\nAfter:  0.66s\\n\\nThe effect was also measured using one of the microbenchmarks that we\\nnormally use to benchmark the allocator [2], after modifying it to make\\nthe appropriate mprotect calls [3]. With an allocation size of 131072\\nbytes to trigger the allocator's \\\"large allocation\\\" code path the\\nper-iteration time was measured as follows:\\n\\nBefore: 27450ns\\nAfter:   6010ns\\n\\nThis patch means that we do more work during the mprotect call itself in\\nexchange for less work when the pages are accessed.  In the worst case,\\nthe pages are not accessed at all.  The effect of this patch in such cases\\nwas measured using the following program:\\n\\n  #include <string.h>\\n  #include <sys/mman.h>\\n\\n  enum { kSize = 131072 };\\n\\n  int main(int argc, char **argv) {\\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\\n    memset(addr, 1, kSize);\\n    for (int i = 0; i != 100000; ++i) {\\n#ifdef PAGE_FAULT\\n      memset(addr + (i * 4096) % kSize, i, 4096);\\n#endif\\n      mprotect((void *)addr, kSize, PROT_NONE);\\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\\n    }\\n  }\\n\\nWith PAGE_FAULT undefined (0 pages touched after removing write\\nprotection) the median real time execution time of 100 runs was measured\\nas follows:\\n\\nBefore: 0.330260s\\nAfter:  0.338836s\\n\\nWith PAGE_FAULT defined (1 page touched) the measurements were\\nas follows:\\n\\nBefore: 0.438048s\\nAfter:  0.355661s\\n\\nSo it seems that even with a single page fault the new approach is faster.\\n\\nI saw similar results if I adjusted the programs to use a larger mapping\\nsize.  With kSize = 1048576 I get these numbers with PAGE_FAULT undefined:\\n\\nBefore: 1.428988s\\nAfter:  1.512016s\\n\\ni.e. around 5.5%.\\n\\nAnd these with PAGE_FAULT defined:\\n\\nBefore: 1.518559s\\nAfter:  1.524417s\\n\\ni.e. about the same.\\n\\nWhat I think we may conclude from these results is that for smaller\\nmappings the advantage of the previous approach, although measurable, is\\nwiped out by a single page fault.  I think we may expect that there should\\nbe at least one access resulting in a page fault (under the previous\\napproach) after making the pages writable, since the program presumably\\nmade the pages writable for a reason.\\n\\nFor larger mappings we may guesstimate that the new approach wins if the\\ndensity of future page faults is > 0.4%.  But for the mappings that are\\nlarge enough for density to matter (not just the absolute number of page\\nfaults) it doesn't seem like the increase in mprotect latency would be\\nvery large relative to the total mprotect execution time.\\n\\nLink: https://lkml.kernel.org/r/20210527190453.125902-1-pcc@google.com\\nLink: https://linux-review.googlesource.com/id/I98d75ef90e20330c578871c87494d64b1df3f1b8\\nLink: [1] https://source.android.com/devices/tech/debug/scudo\\nLink: [2] https://cs.android.com/android/platform/superproject/+/master:bionic/benchmarks/stdliv_benchmark.cpp;l=53;drc=e8693e78711e8f45ccd2b610e4dbe0b94d551cc9\\nLink: [3] https://github.com/pcc/llvm-project/commit/scudo-mprotect-secondary2\\nSigned-off-by: Peter Collingbourne <pcc@google.com>\\nReviewed-by: Peter Xu <peterx@redhat.com>\\nCc: Kostya Kortchinsky <kostyak@google.com>\\nCc: Evgenii Stepanov <eugenis@google.com>\\nCc: Andrea Arcangeli <aarcange@redhat.com>\\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\\nSigned-off-by: Stephen Rothwell <sfr@canb.auug.org.au>\\n(cherry picked from commit e2037f9c0c61ed6964bb1291292ae88f073a100c\\n https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git akpm)\\n[pcc: squashed v4->v5 diff which appeared as a separate commit: ec7563ea9f6a470e9bb532b024ce29d9474daf24]\\nChange-Id: Ic3994b2ec914d3f62f95c1ef338986e350e69e36\\nBug: 191165850\",\n        \"root_cause\": \"The vulnerability is related to the Scudo memory allocator. When a memory region is deallocated, it should be protected with `PROT_NONE`. Later, when the region is to be reused, it needs to be made writable using `mprotect(PROT_READ|PROT_WRITE)`. Before the fix, after removing write protection, any writes would lead to page faults and enter copy-on-write, which impacts performance. The fix makes pages in anonymous mappings referenced by a single PTE immediately writable during mprotect to avoid these page faults.\",\n        \"weaknesses\": [\n          \"Inefficient memory protection mechanism\"\n        ],\n        \"impact\": \"Performance degradation due to unnecessary page faults when writing to memory regions after removing write protection.\",\n        \"attack_vectors\": [\n            \"Exploiting the inefficiency in memory protection by triggering frequent allocations and deallocations.\"\n         ],\n         \"required_capabilities\": \"An attacker needs the ability to allocate and deallocate memory regions.\"\n      },\n      {\n       \"type\": \"commit message\",\n       \"content\": \"Revert \\\"FROMGIT: mm: improve mprotect(R|W) efficiency on pages referenced once\\\"\\n\\nThis reverts commit 6f9aba5a20b84a20848cc444a304f4ada6538b39.\\n\\nReason for revert: Breaks CTS\\n\\nChange-Id: I88ce3506b4881a7d8dae0aaf687dba602a0ca0f2\\nSigned-off-by: Quentin Perret <qperret@google.com>\",\n        \"root_cause\": \"This commit message indicates a revert of the original fix for CVE-2021-39802.\",\n        \"weaknesses\": [],\n        \"impact\": \"Reverting the fix reintroduces the performance degradation issue.\",\n        \"attack_vectors\": [],\n         \"required_capabilities\": \"N/A\"\n      },\n      {\n        \"type\": \"commit message\",\n         \"content\": \"FROMGIT: mm: improve mprotect(R|W) efficiency on pages referenced once\\n\\nIn the Scudo memory allocator [1] we would like to be able to detect\\nuse-after-free vulnerabilities involving large allocations by issuing\\nmprotect(PROT_NONE) on the memory region used for the allocation when\\nit is deallocated.  Later on, after the memory region has been\\n\\\"quarantined\\\" for a sufficient period of time we would like to be able\\nto use it for another allocation by issuing mprotect(PROT_READ|PROT_WRITE).\\n\\nBefore this patch, after removing the write protection, any writes to the\\nmemory region would result in page faults and entering the copy-on-write\\ncode path, even in the usual case where the pages are only referenced by a\\nsingle PTE, harming performance unnecessarily.  Make it so that any pages\\nin anonymous mappings that are only referenced by a single PTE are\\nimmediately made writable during the mprotect so that we can avoid the\\npage faults.\\n\\nThis program shows the critical syscall sequence that we intend to use in\\nthe allocator:\\n\\n  #include <string.h>\\n  #include <sys/mman.h>\\n\\n  enum { kSize = 131072 };\\n\\n  int main(int argc, char **argv) {\\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\\n    for (int i = 0; i != 100000; ++i) {\\n      memset(addr, i, kSize);\\n      mprotect((void *)addr, kSize, PROT_NONE);\\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\\n    }\\n  }\\n\\nThe effect of this patch on the above program was measured on a\\nDragonBoard 845c by taking the median real time execution time of 10 runs.\\n\\nBefore: 3.19s\\nAfter:  0.79s\\n\\nThe effect was also measured using one of the microbenchmarks that we\\nnormally use to benchmark the allocator [2], after modifying it to make\\nthe appropriate mprotect calls [3]. With an allocation size of 131072\\nbytes to trigger the allocator's \\\"large allocation\\\" code path the\\nper-iteration time was measured as follows:\\n\\nBefore: 33364ns\\nAfter:   6886ns\\n\\nThis patch means that we do more work during the mprotect call itself in\\nexchange for less work when the pages are accessed.  In the worst case,\\nthe pages are not accessed at all.  The effect of this patch in such cases\\nwas measured using the following program:\\n\\n  #include <string.h>\\n  #include <sys/mman.h>\\n\\n  enum { kSize = 131072 };\\n\\n  int main(int argc, char **argv) {\\n    char *addr = (char *)mmap(0, kSize, PROT_READ | PROT_WRITE,\\n                             MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\\n    memset(addr, 1, kSize);\\n    for (int i = 0; i != 100000; ++i) {\\n#ifdef PAGE_FAULT\\n      memset(addr + (i * 4096) % kSize, i, 4096);\\n#endif\\n      mprotect((void *)addr, kSize, PROT_NONE);\\n      mprotect((void *)addr, kSize, PROT_READ | PROT_WRITE);\\n    }\\n  }\\n\\nWith PAGE_FAULT undefined (0 pages touched after removing write\\nprotection) the median real time execution time of 100 runs was measured\\nas follows:\\n\\nBefore: 0.325928s\\nAfter:  0.365493s\\n\\nWith PAGE_FAULT defined (1 page touched) the measurements were\\nas follows:\\n\\nBefore: 0.441516s\\nAfter:  0.380251s\\n\\nSo it seems that even with a single page fault the new approach is faster.\\n\\nI saw similar results if I adjusted the programs to use a larger mapping\\nsize.  With kSize = 1048576 I get these numbers with PAGE_FAULT undefined:\\n\\nBefore: 1.563078s\\nAfter:  1.607476s\\n\\ni.e. around 3%.\\n\\nAnd these with PAGE_FAULT defined:\\n\\nBefore: 1.684663s\\nAfter:  1.683272s\\n\\ni.e. about the same.\\n\\nWhat I think we may conclude from these results is that for smaller\\nmappings the advantage of the previous approach, although measurable, is\\nwiped out by a single page fault.  I think we may expect that there should\\nbe at least one access resulting in a page fault (under the previous\\napproach) after making the pages writable, since the program presumably\\nmade the pages writable for a reason.\\n\\nFor larger mappings we may guesstimate that the new approach wins if the\\ndensity of future page faults is > 0.4%.  But for the mappings that are\\nlarge enough for density to matter (not just the absolute number of page\\nfaults) it doesn't seem like the increase in mprotect latency would be\\nvery large relative to the total mprotect execution time.\\n\\nLink: https://lkml.kernel.org/r/20211230004134.1185017-1-pcc@google.com\\nLink: https://linux-review.googlesource.com/id/I98d75ef90e20330c578871c87494d64b1df3f1b8\\nLink: [1] https://source.android.com/devices/tech/debug/scudo\\nLink: [2] https://cs.android.com/android/platform/superproject/+/master:bionic/benchmarks/stdliv_benchmark.cpp;l=53;drc=e8693e78711e8f45ccd2b610e4dbe0b94d551cc9\\nLink: [3] https://github.com/pcc/llvm-project/commit/scudo-mprotect-secondary\\nSigned-off-by: Peter Collingbourne <pcc@google.com>\\nCc: Kostya Kortchinsky <kostyak@google.com>\\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\\nSigned-off-by: Stephen Rothwell <sfr@canb.auug.org.au>\\n(cherry picked from commit 2a9e75c907fa2de626d77dd4051fc038f0dbaaf52\\n https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git akpm)\\nBug: 135772972\\nChange-Id: I98d75ef90e20330c578871c87494d64b1df3f1b8\",\n         \"root_cause\": \"The vulnerability is related to the Scudo memory allocator. When a memory region is deallocated, it should be protected with `PROT_NONE`. Later, when the region is to be reused, it needs to be made writable using `mprotect(PROT_READ|PROT_WRITE)`. Before the fix, after removing write protection, any writes would lead to page faults and enter copy-on-write, which impacts performance. The fix makes pages in anonymous mappings referenced by a single PTE immediately writable during mprotect to avoid these page faults.\",\n        \"weaknesses\": [\n          \"Inefficient memory protection mechanism\"\n        ],\n        \"impact\": \"Performance degradation due to unnecessary page faults when writing to memory regions after removing write protection.\",\n        \"attack_vectors\": [\n            \"Exploiting the inefficiency in memory protection by triggering frequent allocations and deallocations.\"\n         ],\n         \"required_capabilities\": \"An attacker needs the ability to allocate and deallocate memory regions.\"\n      },\n      {\n        \"type\": \"commit message\",\n        \"content\": \"Revert \\\"FROMGIT: mm: improve mprotect(R|W) efficiency on pages referenced once\\\"\\n\\nThis reverts commit b44e46bb047d136bc8977497b6fc2a9f08740321.\\n\\nReason for revert:\\n\\nThe patch has not yet landed upstream, following feedback from Linus:\\nhttps://lore.kernel.org/all/CAHk-=wj4KCuJAH_oPh40Bkp48amM4MXr+8AcbZ=qd5LF4Q+TDg@mail.gmail.com/#t\\n\\nBug: 213339151\\nSigned-off-by: Peter Collingbourne <pcc@google.com>\\nChange-Id: I81c2cef4076487df1dd0ee75449dcb2371ac1dbc\",\n        \"root_cause\": \"This commit message indicates another revert of the fix for CVE-2021-39802 due to upstream issues.\",\n        \"weaknesses\": [],\n        \"impact\": \"Reverting the fix reintroduces the performance degradation issue.\",\n        \"attack_vectors\": [],\n        \"required_capabilities\": \"N/A\"\n      }\n    ],\n    \"summary\": \"The vulnerability relates to the Scudo memory allocator and its inefficient use of mprotect when transitioning memory from read-only to read-write, leading to performance degradation from unnecessary page faults. The fix aimed to make memory pages immediately writable to avoid these faults, but it was reverted due to issues in the CTS tests and problems with upstream kernel acceptance.\"\n  }\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 667 | Improper Locking | Class | Allowed-with-Review | sparse | 0.381 |\n| 2 | 362 | Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') | Class | Allowed-with-Review | sparse | 0.374 |\n| 3 | 862 | Missing Authorization | Class | Allowed-with-Review | sparse | 0.367 |\n| 4 | 413 | Improper Resource Locking | Base | Allowed | sparse | 0.362 |\n| 5 | 665 | Improper Initialization | Class | Discouraged | sparse | 0.350 |\n| 6 | 1260 | Improper Handling of Overlap Between Protected Memory Ranges | Base | Allowed | dense | 0.589 |\n| 7 | 364 | Signal Handler Race Condition | Base | Allowed | graph | 0.002 |\n| 8 | 1021 | Improper Restriction of Rendered UI Layers or Frames | Base | Allowed | sparse | 0.347 |\n| 9 | 514 | Covert Channel | Class | Allowed-with-Review | sparse | 0.345 |\n| 10 | 732 | Incorrect Permission Assignment for Critical Resource | Class | Allowed-with-Review | sparse | 0.344 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-667: Improper Locking\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.\n\n### Extended Description\n\n\nLocking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\nChildOf -> CWE-662\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.\n\n\n\n### Observed Examples\n- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.\n- **CVE-2009-0935:** Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice\n- **CVE-2010-4210:** function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.\n\n\n\n\n## CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently.\n\n### Extended Description\n\n\nA race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.\n\n\nA race condition violates these properties, which are closely related:\n\n\n  - Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.\n\n  - Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource.\n\nA race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity.\n\nThe interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.\n\n\n### Alternative Terms\nRace Condition\n\n### Relationships\nChildOf -> CWE-691\nCanPrecede -> CWE-416\nCanPrecede -> CWE-476\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Maintenance]** The relationship between race conditions and synchronization problems (CWE-662) needs to be further developed. They are not necessarily two perspectives of the same core concept, since synchronization is only one technique for avoiding race conditions, and synchronization can be used for other purposes besides race condition prevention.\n\n**[Research Gap]** Race conditions in web applications are under-studied and probably under-reported. However, in 2008 there has been growing interest in this area.\n\n**[Research Gap]** Much of the focus of race condition research has been in Time-of-check Time-of-use (TOCTOU) variants (CWE-367), but many race conditions are related to synchronization problems that do not necessarily require a time-of-check.\n\n**[Research Gap]** From a classification/taxonomy perspective, the relationships between concurrency and program state need closer investigation and may be useful in organizing related issues.\n\n\n\n### Observed Examples\n- **CVE-2022-29527:** Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.\n- **CVE-2021-1782:** Chain: improper locking (CWE-667) leads to race condition (CWE-362), as exploited in the wild per CISA KEV.\n- **CVE-2021-0920:** Chain: mobile platform race condition (CWE-362) leading to use-after-free (CWE-416), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-862: Missing Authorization\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product does not perform an authorization check when an actor attempts to access a resource or perform an action.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nAuthZ: \"AuthZ\" is typically used as an abbreviation of \"authorization\" within the web application security community. It is distinct from \"AuthN\" (or, sometimes, \"AuthC\") which is an abbreviation of \"authentication.\" The use of \"Auth\" as an abbreviation is discouraged, since it could be used for either authentication or authorization.\n\n### Relationships\nChildOf -> CWE-285\nChildOf -> CWE-284\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Terminology]** Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.\n\n\n\n### Observed Examples\n- **CVE-2022-24730:** Go-based continuous deployment product does not check that a user has certain privileges to update or create an app, allowing adversaries to read sensitive repository information\n- **CVE-2009-3168:** Web application does not restrict access to admin scripts, allowing authenticated users to reset administrative passwords.\n- **CVE-2009-3597:** Web application stores database file under the web root with insufficient access control (CWE-219), allowing direct request.\n\n\n\n\n## CWE-413: Improper Resource Locking\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not lock or does not correctly lock a resource when the product must have exclusive access to the resource.\n\n### Extended Description\nWhen a resource is not properly locked, an attacker could modify the resource while it is being operated on by the product. This might violate the product's assumption that the resource will not change, potentially leading to unexpected behaviors.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-667\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2022-20141:** Chain: an operating system kernel has insufficent resource locking (CWE-413) leading to a use after free (CWE-416).\n\n\n\n\n## CWE-665: Improper Initialization\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used.\n\n### Extended Description\nThis can have security implications when the associated resource is expected to have certain properties or values, such as a variable that determines whether a user has been authenticated or not.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-664\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n\n### Observed Examples\n- **CVE-2001-1471:** chain: an invalid value prevents a library file from being included, skipping initialization of key variables, leading to resultant eval injection.\n- **CVE-2008-3637:** Improper error checking in protection mechanism produces an uninitialized variable, allowing security bypass and code execution.\n- **CVE-2008-4197:** Use of uninitialized memory may allow code execution.\n\n\n\n\n## CWE-1260: Improper Handling of Overlap Between Protected Memory Ranges\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product allows address regions to overlap, which can result in the bypassing of intended memory protection.\n\n### Extended Description\n\n\nIsolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software.\n\n\nIf a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-284\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** As of CWE 4.6, CWE-1260 and CWE-1316 are siblings under view 1000, but CWE-1260 might be a parent of CWE-1316. More analysis is warranted.\n\n\n\n### Observed Examples\n- **CVE-2008-7096:** virtualization product allows compromise of hardware product by accessing certain remapping registers.\n- **[REF-1100]:** processor design flaw allows ring 0 code to access more privileged rings by causing a register window to overlap a range of protected system RAM [REF-1100]\n\n\n\n\n## CWE-364: Signal Handler Race Condition\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product uses a signal handler that introduces a race condition.\n\n### Extended Description\n\n\nRace conditions frequently occur in signal handlers, since signal handlers support asynchronous actions. These race conditions have a variety of root causes and symptoms. Attackers may be able to exploit a signal handler race condition to cause the product state to be corrupted, possibly leading to a denial of service or even code execution.\n\n\nThese issues occur when non-reentrant functions, or state-sensitive actions occur in the signal handler, where they may be called at any time. These behaviors can violate assumptions being made by the \"regular\" code that is interrupted, or by other signal handlers that may also be invoked. If these functions are called at an inopportune moment - such as while a non-reentrant function is already running - memory corruption could occur that may be exploitable for code execution. Another signal race condition commonly found occurs when free is called within a signal handler, resulting in a double free and therefore a write-what-where condition. Even if a given pointer is set to NULL after it has been freed, a race condition still exists between the time the memory was freed and the pointer was set to NULL. This is especially problematic if the same signal handler has been set for more than one signal -- since it means that the signal handler itself may be reentered.\n\n\nThere are several known behaviors related to signal handlers that have received the label of \"signal handler race condition\":\n\n\n  - Shared state (e.g. global data or static variables) that are accessible to both a signal handler and \"regular\" code\n\n  - Shared state between a signal handler and other signal handlers\n\n  - Use of non-reentrant functionality within a signal handler - which generally implies that shared state is being used. For example, malloc() and free() are non-reentrant because they may use global or static data structures for managing memory, and they are indirectly used by innocent-seeming functions such as syslog(); these functions could be exploited for memory corruption and, possibly, code execution.\n\n  - Association of the same signal handler function with multiple signals - which might imply shared state, since the same code and resources are accessed. For example, this can be a source of double-free and use-after-free weaknesses.\n\n  - Use of setjmp and longjmp, or other mechanisms that prevent a signal handler from returning control back to the original functionality\n\n  - While not technically a race condition, some signal handlers are designed to be called at most once, and being called more than once can introduce security problems, even when there are not any concurrent calls to the signal handler. This can be a source of double-free and use-after-free weaknesses.\n\nSignal handler vulnerabilities are often classified based on the absence of a specific protection mechanism, although this style of classification is discouraged in CWE because programmers often have a choice of several different mechanisms for addressing the weakness. Such protection mechanisms may preserve exclusivity of access to the shared resource, and behavioral atomicity for the relevant code:\n\n  - Avoiding shared state\n\n  - Using synchronization in the signal handler\n\n  - Using synchronization in the regular code\n\n  - Disabling or masking other signals, which provides atomicity (which effectively ensures exclusivity)\n\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-362\nCanPrecede -> CWE-415\nCanPrecede -> CWE-416\nCanPrecede -> CWE-123\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-1999-0035:** Signal handler does not disable other signal handlers, allowing it to be interrupted, causing other functionality to access files/etc. with raised privileges\n- **CVE-2001-0905:** Attacker can send a signal while another signal handler is already running, leading to crash or execution with root privileges\n- **CVE-2001-1349:** unsafe calls to library functions from signal handler\n\n\n\n\n## CWE-1021: Improper Restriction of Rendered UI Layers or Frames\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe web application does not restrict or incorrectly restricts frame objects or UI layers that belong to another application or domain, which can lead to user confusion about which interface the user is interacting with.\n\n### Extended Description\nA web application is expected to place restrictions on whether it is allowed to be rendered within frames, iframes, objects, embed or applet elements. Without the restrictions, users can be tricked into interacting with the application when they were not intending to.\n\n### Alternative Terms\nClickjacking\nUI Redress Attack\nTapjacking: \"Tapjacking\" is similar to clickjacking, except it is used for mobile applications in which the user \"taps\" the application instead of performing a mouse click.\n\n### Relationships\nChildOf -> CWE-441\nChildOf -> CWE-610\nChildOf -> CWE-451\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2017-7440:** E-mail preview feature in a desktop application allows clickjacking attacks via a crafted e-mail message\n- **CVE-2017-5697:** Hardware/firmware product has insufficient clickjacking protection in its web user interface\n- **CVE-2017-4015:** Clickjacking in data-loss prevention product via HTTP response header.\n\n\n\n\n## CWE-514: Covert Channel\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nA covert channel is a path that can be used to transfer information in a way not intended by the system's designers.\n\n### Extended Description\nTypically the system has not given authorization for the transmission and has no knowledge of its occurrence.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-1229\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This CWE entry is a Class and might have Base-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Theoretical]** A covert channel can be thought of as an emergent resource, meaning that it was not an originally intended resource, however it exists due the application's behaviors.\n\n**[Maintenance]** As of CWE 4.9, members of the CWE Hardware SIG are working to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks that create or exploit covert channels. As a result of that work, this entry might change in CWE 4.10.\n\n\n\n\n\n\n## CWE-732: Incorrect Permission Assignment for Critical Resource\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.\n\n### Extended Description\nWhen a resource is given a permission setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution, or sensitive user data. For example, consider a misconfigured storage account for the cloud that can be read or written by a public or anonymous user.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-285\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** While the name itself indicates an assignment of permissions for resources, this is often misused for vulnerabilities in which \"permissions\" are not checked, which is an \"authorization\" weakness (CWE-285 or descendants) within CWE's model [REF-1287].\n**Comments:** Closely analyze the specific mistake that is allowing the resource to be exposed, and perform a CWE mapping for that mistake.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Maintenance]** The relationships between privileges, permissions, and actors (e.g. users and groups) need further refinement within the Research view. One complication is that these concepts apply to two different pillars, related to control of resources (CWE-664) and protection mechanism failures (CWE-693).\n\n\n\n### Observed Examples\n- **CVE-2022-29527:** Go application for cloud management creates a world-writable sudoers file that allows local attackers to inject sudo rules and escalate privileges to root by winning a race condition.\n- **CVE-2009-3482:** Anti-virus product sets insecure \"Everyone: Full Control\" permissions for files under the \"Program Files\" folder, allowing attackers to replace executables with Trojan horses.\n- **CVE-2009-3897:** Product creates directories with 0777 permissions at installation, allowing users to gain privileges and access a socket used for authentication.\n\n",
  "keyphrases": {},
  "timestamp": "2025-04-01 19:31:03",
  "cve_id": "unknown",
  "result_count": 5,
  "results": [
    {
      "cwe_id": "667",
      "name": "Improper Locking",
      "score": 8433.76649247563,
      "search_source": "base_query"
    },
    {
      "cwe_id": "364",
      "name": "Signal Handler Race Condition",
      "score": 8393.349522183646,
      "search_source": "base_query"
    },
    {
      "cwe_id": "362",
      "name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
      "score": 8344.735144853006,
      "search_source": "base_query"
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "score": 7615.699406878719,
      "search_source": "base_query"
    },
    {
      "cwe_id": "367",
      "name": "Time-of-check Time-of-use (TOCTOU) Race Condition",
      "score": 7581.687815316624,
      "search_source": "base_query"
    }
  ]
}