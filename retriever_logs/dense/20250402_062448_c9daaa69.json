{
  "retriever": "dense",
  "query": "## Vulnerability Description\nIn NTFS-3G versions < 2021.8.22, when specially crafted NTFS attributes are read in the function ntfs_attr_pread_i, a **heap buffer overflow** can occur and allow for writing to arbitrary memory or denial of service of the application.\n\n### Vulnerability Description Key Phrases\n- **weakness:** **heap buffer overflow**\n- **impact:** writing to arbitrary memory and denial of service\n- **vector:** specially crafted NTFS attributes\n- **product:** NTFS-3G\n- **version:** < 2021.8.22\n- **component:** ntfs_attr_pread_i function\n\n## CVE Reference Links Content Summary\n```\n{\n  \"CVE-2021-33287\": {\n    \"root_cause\": \"The vulnerability exists due to improper bounds checking when processing NTFS attributes in the ntfs_attr_pread_i function, leading to a heap buffer overflow.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\"\n    ],\n    \"impact\": \"The vulnerability can lead to arbitrary memory writes or a denial of service.\",\n    \"attack_vectors\": \"Local access to a system with a maliciously crafted NTFS-formatted image file.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39254\": {\n    \"root_cause\": \"Integer overflow in memmove when resizing attribute records.\",\n    \"weaknesses\": [\n      \"Integer Overflow\",\n      \"Heap-based buffer overflow\"\n    ],\n     \"impact\": \"A crafted NTFS image can cause a heap-based buffer overflow which could lead to arbitrary code execution.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n    \"CVE-2021-39256\": {\n    \"root_cause\": \"A heap-based buffer overflow vulnerability in ntfs_inode_lookup_by_name.\",\n    \"weaknesses\": [\n       \"Heap-based buffer overflow\"\n    ],\n    \"impact\": \"A crafted NTFS image can cause a heap-based buffer overflow.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-35269\": {\n    \"root_cause\": \"A heap buffer overflow in ntfs_attr_setup_flag when setting up an NTFS attribute from the MFT.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\",\n      \"Improper Privilege Management\"\n     ],\n    \"impact\": \"Code execution and/or privilege escalation\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-35266\": {\n    \"root_cause\": \"A heap buffer overflow can occur when a specially crafted NTFS inode pathname is supplied.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\"\n    ],\n    \"impact\": \"Memory disclosure, denial of service and/or code execution.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n    \"CVE-2021-35268\": {\n    \"root_cause\": \"A heap buffer overflow in the ntfs_inode_real_open function when loading a crafted NTFS inode.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\"\n    ],\n    \"impact\": \"Code execution and/or privilege escalation.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39252\": {\n    \"root_cause\": \"Out-of-bounds read vulnerability in ntfs_ie_lookup.\",\n    \"weaknesses\": [\n      \"Out-of-bounds read\"\n    ],\n    \"impact\": \"A crafted NTFS image can cause an out-of-bounds read.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39253\": {\n    \"root_cause\": \"Out-of-bounds read in ntfs_runlists_merge_i.\",\n    \"weaknesses\": [\n       \"Out-of-bounds read\"\n    ],\n    \"impact\": \"A crafted NTFS image can trigger an out-of-bounds read.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n   },\n    \"CVE-2021-39260\": {\n    \"root_cause\": \"Out-of-bounds access in ntfs_inode_sync_standard_information.\",\n      \"weaknesses\": [\n        \"Buffer Overflow\",\n        \"Out-of-bounds access\"\n     ],\n    \"impact\": \"A crafted NTFS image can cause an out-of-bounds access.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39255\": {\n    \"root_cause\": \"Out-of-bounds read due to an invalid attribute in ntfs_attr_find_in_attrdef.\",\n    \"weaknesses\": [\n      \"Out-of-bounds read\"\n    ],\n     \"impact\": \"A crafted NTFS image can trigger an out-of-bounds read.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39251\": {\n    \"root_cause\": \"NULL pointer dereference vulnerability in ntfs_extent_inode_open.\",\n    \"weaknesses\": [\n       \"NULL pointer dereference\"\n    ],\n      \"impact\": \"A crafted NTFS image can cause a NULL pointer dereference.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39261\": {\n      \"root_cause\": \"A heap-based buffer overflow in ntfs_compressed_pwrite.\",\n    \"weaknesses\": [\n      \"Heap-based buffer overflow\"\n    ],\n     \"impact\": \"A crafted NTFS image can cause a heap-based buffer overflow\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39262\": {\n       \"root_cause\": \"Out-of-bounds access in ntfs_decompress\",\n    \"weaknesses\": [\n       \"Buffer Overflow\",\n        \"Out-of-bounds access\"\n     ],\n     \"impact\": \"A crafted NTFS image can cause an out-of-bounds access.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n    },\n  \"CVE-2021-39263\": {\n    \"root_cause\": \"A heap-based buffer overflow, caused by an unsanitized attribute in ntfs_get_attribute_value.\",\n    \"weaknesses\": [\n      \"Heap-based buffer overflow\"\n    ],\n    \"impact\": \"A crafted NTFS image can trigger a heap-based buffer overflow.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-33285\":{\n        \"root_cause\": \"Out-of-bounds heap buffer access in ntfs_get_attribute_value() due to incorrect check of bytes_in_use value in MFT records.\",\n        \"weaknesses\": [\n            \"Out-of-bounds heap buffer access\"\n        ],\n        \"impact\": \"Heap buffer overflow and potential code execution.\",\n        \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n        \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-33289\":{\n        \"root_cause\": \"A heap buffer overflow can occur when a specially crafted MFT section is supplied in an NTFS image.\",\n        \"weaknesses\": [\n            \"Heap buffer overflow\"\n        ],\n        \"impact\": \"Heap buffer overflow and potential code execution.\",\n        \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n        \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-33286\":{\n        \"root_cause\": \"A heap buffer overflow can occur when a specially crafted unicode string is supplied in an NTFS image\",\n        \"weaknesses\": [\n             \"Heap buffer overflow\"\n        ],\n        \"impact\": \"Code execution.\",\n        \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n         \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-35267\":{\n        \"root_cause\": \"A stack buffer overflow when correcting differences in the MFT and MFTMirror.\",\n         \"weaknesses\": [\n             \"Stack buffer overflow\"\n        ],\n        \"impact\": \"Code execution or escalation of privileges when setuid-root.\",\n         \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n          \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n      }\n  }\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |\n| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |\n| 3 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.338 |\n| 4 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.266 |\n| 5 | 126 | Buffer Over-read | Variant | Allowed | sparse | 0.264 |\n| 6 | 1386 | Insecure Operation on Windows Junction / Mount Point | Base | Allowed | dense | 0.559 |\n| 7 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |\n| 8 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.263 |\n| 9 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.262 |\n| 10 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.254 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nBuffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean \"write past the end of a buffer,\" whereas others use the same term to mean \"any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer.\" Others could mean \"any action after the end of a buffer, whether it is a read or write.\" Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.\nbuffer overrun: Some prominent vendors and researchers use the term \"buffer overrun,\" but most people use \"buffer overflow.\" See the alternate term for \"buffer overflow\" for context.\nmemory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the \"memory safety\" term.\n\n### Relationships\nChildOf -> CWE-118\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.\n**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nIt is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.\n\n\n\n\n### Observed Examples\n- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.\n- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n\n\n\n## CWE-193: Off-by-one Error\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\noff-by-five: An \"off-by-five\" error was reported for sudo in 2002 (CVE-2002-0184), but that is more like a \"length calculation\" error.\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nCanPrecede -> CWE-617\nCanPrecede -> CWE-170\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is not always a buffer overflow. For example, an off-by-one error could be a factor in a partial comparison, a read from the wrong memory location, an incorrect conditional, etc.\n\n\n\n### Observed Examples\n- **CVE-2003-0252:** Off-by-one error allows remote attackers to cause a denial of service and possibly execute arbitrary code via requests that do not contain newlines.\n- **CVE-2001-1391:** Off-by-one vulnerability in driver allows users to modify kernel memory.\n- **CVE-2002-0083:** Off-by-one error allows local users or remote malicious servers to gain privileges.\n\n\n\n\n## CWE-126: Buffer Over-read\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.\n\n### Extended Description\nThis typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-125\nChildOf -> CWE-788\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** These problems may be resultant from missing sentinel values (CWE-463) or trusting a user-influenced input length variable.\n\n\n\n### Observed Examples\n- **CVE-2022-1733:** Text editor has out-of-bounds read past end of line while indenting C code\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated, leading to buffer over-read or heap-based buffer overflow.\n\n\n\n\n## CWE-1386: Insecure Operation on Windows Junction / Mount Point\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product opens a file or directory, but it does not properly prevent the name from being associated with a junction or mount point to a destination that is outside of the intended control sphere.\n\n### Extended Description\n\n\nDepending on the intended action being performed, this could allow an attacker to cause the product to read, write, delete, or otherwise operate on unauthorized files.\n\n\nIn Windows, NTFS5 allows for file system objects called reparse points. Applications can create a hard link from one directory to another directory, called a junction point. They can also create a mapping from a directory to a drive letter, called a mount point. If a file is used by a privileged program, but it can be replaced with a hard link to a sensitive file (e.g., AUTOEXEC.BAT), an attacker could excalate privileges. When the process opens the file, the attacker can assume the privileges of that process, tricking the privileged process to read, modify, or delete the sensitive file, preventing the program from accurately processing data. Note that one can also point to registries and semaphores.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-59\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** Symbolic links, hard links, junctions, and mount points can be confusing terminology, as there are differences in how they operate between UNIX-based systems and Windows, and there are interactions between them.\n\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2021-26426:** Privileged service allows attackers to delete unauthorized files using a directory junction, leading to arbitrary code execution as SYSTEM.\n- **CVE-2020-0863:** By creating a mount point and hard links, an attacker can abuse a service to allow users arbitrary file read permissions.\n- **CVE-2019-1161:** Chain: race condition (CWE-362) in anti-malware product allows deletion of files by creating a junction (CWE-1386) and using hard links during the time window in which a temporary file is created and deleted.\n\n\n\n\n## CWE-128: Wrap-around Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nWrap around errors occur whenever a value is incremented past the maximum value for its type and therefore \"wraps around\" to a very small, negative, or undefined value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nCanPrecede -> CWE-119\nPeerOf -> CWE-190\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** The relationship between overflow and wrap-around needs to be examined more closely, since several entries (including CWE-190) are closely related.\n\n\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\nIn NTFS-3G versions < 2021.8.22, when specially crafted NTFS attributes are read in the function ntfs_attr_pread_i, a **heap buffer overflow** can occur and allow for writing to arbitrary memory or denial of service of the application.\n\n### Vulnerability Description Key Phrases\n- **weakness:** **heap buffer overflow**\n- **impact:** writing to arbitrary memory and denial of service\n- **vector:** specially crafted NTFS attributes\n- **product:** NTFS-3G\n- **version:** < 2021.8.22\n- **component:** ntfs_attr_pread_i function\n\n## CVE Reference Links Content Summary\n```\n{\n  \"CVE-2021-33287\": {\n    \"root_cause\": \"The vulnerability exists due to improper bounds checking when processing NTFS attributes in the ntfs_attr_pread_i function, leading to a heap buffer overflow.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\"\n    ],\n    \"impact\": \"The vulnerability can lead to arbitrary memory writes or a denial of service.\",\n    \"attack_vectors\": \"Local access to a system with a maliciously crafted NTFS-formatted image file.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39254\": {\n    \"root_cause\": \"Integer overflow in memmove when resizing attribute records.\",\n    \"weaknesses\": [\n      \"Integer Overflow\",\n      \"Heap-based buffer overflow\"\n    ],\n     \"impact\": \"A crafted NTFS image can cause a heap-based buffer overflow which could lead to arbitrary code execution.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n    \"CVE-2021-39256\": {\n    \"root_cause\": \"A heap-based buffer overflow vulnerability in ntfs_inode_lookup_by_name.\",\n    \"weaknesses\": [\n       \"Heap-based buffer overflow\"\n    ],\n    \"impact\": \"A crafted NTFS image can cause a heap-based buffer overflow.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-35269\": {\n    \"root_cause\": \"A heap buffer overflow in ntfs_attr_setup_flag when setting up an NTFS attribute from the MFT.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\",\n      \"Improper Privilege Management\"\n     ],\n    \"impact\": \"Code execution and/or privilege escalation\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-35266\": {\n    \"root_cause\": \"A heap buffer overflow can occur when a specially crafted NTFS inode pathname is supplied.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\"\n    ],\n    \"impact\": \"Memory disclosure, denial of service and/or code execution.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n    \"CVE-2021-35268\": {\n    \"root_cause\": \"A heap buffer overflow in the ntfs_inode_real_open function when loading a crafted NTFS inode.\",\n    \"weaknesses\": [\n      \"Heap buffer overflow\"\n    ],\n    \"impact\": \"Code execution and/or privilege escalation.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39252\": {\n    \"root_cause\": \"Out-of-bounds read vulnerability in ntfs_ie_lookup.\",\n    \"weaknesses\": [\n      \"Out-of-bounds read\"\n    ],\n    \"impact\": \"A crafted NTFS image can cause an out-of-bounds read.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39253\": {\n    \"root_cause\": \"Out-of-bounds read in ntfs_runlists_merge_i.\",\n    \"weaknesses\": [\n       \"Out-of-bounds read\"\n    ],\n    \"impact\": \"A crafted NTFS image can trigger an out-of-bounds read.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n   },\n    \"CVE-2021-39260\": {\n    \"root_cause\": \"Out-of-bounds access in ntfs_inode_sync_standard_information.\",\n      \"weaknesses\": [\n        \"Buffer Overflow\",\n        \"Out-of-bounds access\"\n     ],\n    \"impact\": \"A crafted NTFS image can cause an out-of-bounds access.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39255\": {\n    \"root_cause\": \"Out-of-bounds read due to an invalid attribute in ntfs_attr_find_in_attrdef.\",\n    \"weaknesses\": [\n      \"Out-of-bounds read\"\n    ],\n     \"impact\": \"A crafted NTFS image can trigger an out-of-bounds read.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39251\": {\n    \"root_cause\": \"NULL pointer dereference vulnerability in ntfs_extent_inode_open.\",\n    \"weaknesses\": [\n       \"NULL pointer dereference\"\n    ],\n      \"impact\": \"A crafted NTFS image can cause a NULL pointer dereference.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39261\": {\n      \"root_cause\": \"A heap-based buffer overflow in ntfs_compressed_pwrite.\",\n    \"weaknesses\": [\n      \"Heap-based buffer overflow\"\n    ],\n     \"impact\": \"A crafted NTFS image can cause a heap-based buffer overflow\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-39262\": {\n       \"root_cause\": \"Out-of-bounds access in ntfs_decompress\",\n    \"weaknesses\": [\n       \"Buffer Overflow\",\n        \"Out-of-bounds access\"\n     ],\n     \"impact\": \"A crafted NTFS image can cause an out-of-bounds access.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n     \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n    },\n  \"CVE-2021-39263\": {\n    \"root_cause\": \"A heap-based buffer overflow, caused by an unsanitized attribute in ntfs_get_attribute_value.\",\n    \"weaknesses\": [\n      \"Heap-based buffer overflow\"\n    ],\n    \"impact\": \"A crafted NTFS image can trigger a heap-based buffer overflow.\",\n    \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n    \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-33285\":{\n        \"root_cause\": \"Out-of-bounds heap buffer access in ntfs_get_attribute_value() due to incorrect check of bytes_in_use value in MFT records.\",\n        \"weaknesses\": [\n            \"Out-of-bounds heap buffer access\"\n        ],\n        \"impact\": \"Heap buffer overflow and potential code execution.\",\n        \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n        \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n  \"CVE-2021-33289\":{\n        \"root_cause\": \"A heap buffer overflow can occur when a specially crafted MFT section is supplied in an NTFS image.\",\n        \"weaknesses\": [\n            \"Heap buffer overflow\"\n        ],\n        \"impact\": \"Heap buffer overflow and potential code execution.\",\n        \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n        \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-33286\":{\n        \"root_cause\": \"A heap buffer overflow can occur when a specially crafted unicode string is supplied in an NTFS image\",\n        \"weaknesses\": [\n             \"Heap buffer overflow\"\n        ],\n        \"impact\": \"Code execution.\",\n        \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n         \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n  },\n   \"CVE-2021-35267\":{\n        \"root_cause\": \"A stack buffer overflow when correcting differences in the MFT and MFTMirror.\",\n         \"weaknesses\": [\n             \"Stack buffer overflow\"\n        ],\n        \"impact\": \"Code execution or escalation of privileges when setuid-root.\",\n         \"attack_vectors\": \"Local access, a malicious NTFS image file is required.\",\n          \"required_capabilities\": \"Ability to mount the malicious NTFS image file.\"\n      }\n  }\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 119 | Improper Restriction of Operations within the Bounds of a Memory Buffer | Class | Discouraged | alternate_terms | 0.800 |\n| 2 | 190 | Integer Overflow or Wraparound | Base | Allowed | alternate_terms | 0.800 |\n| 3 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.338 |\n| 4 | 193 | Off-by-one Error | Base | Allowed | sparse | 0.266 |\n| 5 | 126 | Buffer Over-read | Variant | Allowed | sparse | 0.264 |\n| 6 | 1386 | Insecure Operation on Windows Junction / Mount Point | Base | Allowed | dense | 0.559 |\n| 7 | 128 | Wrap-around Error | Base | Allowed | graph | 0.003 |\n| 8 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.263 |\n| 9 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.262 |\n| 10 | 121 | Stack-based Buffer Overflow | Variant | Allowed | sparse | 0.254 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nBuffer Overflow: This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean \"write past the end of a buffer,\" whereas others use the same term to mean \"any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer.\" Others could mean \"any action after the end of a buffer, whether it is a read or write.\" Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.\nbuffer overrun: Some prominent vendors and researchers use the term \"buffer overrun,\" but most people use \"buffer overflow.\" See the alternate term for \"buffer overflow\" for context.\nmemory safety: Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the \"memory safety\" term.\n\n### Relationships\nChildOf -> CWE-118\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-119 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available.\n**Comments:** Look at CWE-119's children and consider mapping to CWEs such as CWE-787: Out-of-bounds Write, CWE-125: Out-of-bounds Read, or others.\n**Reasons:**\n- Frequent Misuse\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nIt is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.\n\n\n\n\n### Observed Examples\n- **CVE-2021-22991:** Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.\n- **CVE-2020-29557:** Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.\n- **CVE-2009-2550:** Classic stack-based buffer overflow in media player using a long entry in a playlist\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n\n\n\n## CWE-193: Off-by-one Error\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\noff-by-five: An \"off-by-five\" error was reported for sudo in 2002 (CVE-2002-0184), but that is more like a \"length calculation\" error.\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nCanPrecede -> CWE-617\nCanPrecede -> CWE-170\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is not always a buffer overflow. For example, an off-by-one error could be a factor in a partial comparison, a read from the wrong memory location, an incorrect conditional, etc.\n\n\n\n### Observed Examples\n- **CVE-2003-0252:** Off-by-one error allows remote attackers to cause a denial of service and possibly execute arbitrary code via requests that do not contain newlines.\n- **CVE-2001-1391:** Off-by-one vulnerability in driver allows users to modify kernel memory.\n- **CVE-2002-0083:** Off-by-one error allows local users or remote malicious servers to gain privileges.\n\n\n\n\n## CWE-126: Buffer Over-read\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.\n\n### Extended Description\nThis typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-125\nChildOf -> CWE-788\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** These problems may be resultant from missing sentinel values (CWE-463) or trusting a user-influenced input length variable.\n\n\n\n### Observed Examples\n- **CVE-2022-1733:** Text editor has out-of-bounds read past end of line while indenting C code\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated, leading to buffer over-read or heap-based buffer overflow.\n\n\n\n\n## CWE-1386: Insecure Operation on Windows Junction / Mount Point\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product opens a file or directory, but it does not properly prevent the name from being associated with a junction or mount point to a destination that is outside of the intended control sphere.\n\n### Extended Description\n\n\nDepending on the intended action being performed, this could allow an attacker to cause the product to read, write, delete, or otherwise operate on unauthorized files.\n\n\nIn Windows, NTFS5 allows for file system objects called reparse points. Applications can create a hard link from one directory to another directory, called a junction point. They can also create a mapping from a directory to a drive letter, called a mount point. If a file is used by a privileged program, but it can be replaced with a hard link to a sensitive file (e.g., AUTOEXEC.BAT), an attacker could excalate privileges. When the process opens the file, the attacker can assume the privileges of that process, tricking the privileged process to read, modify, or delete the sensitive file, preventing the program from accurately processing data. Note that one can also point to registries and semaphores.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-59\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** Symbolic links, hard links, junctions, and mount points can be confusing terminology, as there are differences in how they operate between UNIX-based systems and Windows, and there are interactions between them.\n\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2021-26426:** Privileged service allows attackers to delete unauthorized files using a directory junction, leading to arbitrary code execution as SYSTEM.\n- **CVE-2020-0863:** By creating a mount point and hard links, an attacker can abuse a service to allow users arbitrary file read permissions.\n- **CVE-2019-1161:** Chain: race condition (CWE-362) in anti-malware product allows deletion of files by creating a junction (CWE-1386) and using hard links during the time window in which a temporary file is created and deleted.\n\n\n\n\n## CWE-128: Wrap-around Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nWrap around errors occur whenever a value is incremented past the maximum value for its type and therefore \"wraps around\" to a very small, negative, or undefined value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-682\nCanPrecede -> CWE-119\nPeerOf -> CWE-190\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** The relationship between overflow and wrap-around needs to be examined more closely, since several entries (including CWE-190) are closely related.\n\n\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-121: Stack-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nStack Overflow: \"Stack Overflow\" is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.\n\n\n\n### Observed Examples\n- **CVE-2021-35395:** Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.\n\n"
  },
  "timestamp": "2025-04-02 06:24:48",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.7790148219493921
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 0.7735319910944949
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "Base",
      "score": 0.7617175232542183
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.7596585788084126
    },
    {
      "cwe_id": "124",
      "name": "Buffer Underwrite ('Buffer Underflow')",
      "type": "Base",
      "score": 0.7543135189975518
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "Base",
      "score": 0.7525526354780511
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 0.7466905886667606
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "Variant",
      "score": 0.7466370778093904
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "type": "Base",
      "score": 0.7464560882093838
    },
    {
      "cwe_id": "119",
      "name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
      "type": "Class",
      "score": 0.7434967541294568
    }
  ]
}