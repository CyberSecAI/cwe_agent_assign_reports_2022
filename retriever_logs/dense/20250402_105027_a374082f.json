{
  "retriever": "dense",
  "query": "## Vulnerability Description\nMultiple code execution vulnerabilities exists in the Nef polygon-parsing functionality of CGAL libcgal CGAL-5.1.1. A specially crafted malformed file can lead to an **out-of-bounds read** and **type confusion**, which could lead to code execution. An attacker can provide malicious input to trigger any of these vulnerabilities. An oob read vulnerability exists in Nef_S2/SNC_io_parser.h SNC_io_parserread_edge() eh->out_sedge().\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **out-of-bounds read**\n- **weakness:** **type confusion**\n- **impact:** code execution\n- **product:** CGAL libcgal\n- **version:** CGAL-5.1.1\n- **component:** Nef polygon-parsing functionality\n\n## CVE Reference Links Content Summary\n```\n{\n  \"Root cause of vulnerability\": \"Improper validation of array index when parsing Nef polygon data from a file, leading to out-of-bounds reads and type confusion.\",\n  \"Weaknesses/vulnerabilities\": [\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_vertex()` when accessing `Face_of[]`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_vertex()` when accessing `Halfedge_of[]`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_prev()`\",\n     \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_next()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_vertex()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_face()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_face()` when calling `set_halfedge()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_face()` when calling `store_fc()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_face()` when calling `store_iv()`\",\n    \"Out-of-bounds read in `Nef_S2/SM_io_parser.h` `SM_io_parser::read_vertex()` when calling `set_face()`\",\n    \"Out-of-bounds read in `Nef_S2/SM_io_parser.h` `SM_io_parser::read_vertex()` when calling `set_first_out_edge()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->svertices_begin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->svertices_last()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->shalfedges_begin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->shalfedges_last()`\",\n     \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->sfaces_begin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->sfaces_last()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->shalfloop()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->center_vertex()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->out_sedge()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->incident_sface()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->boundary_entry_objects` using `SEdge_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->boundary_entry_objects` using `SLoop_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->incident_volume()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_volume()` when accessing `ch->shell_entry_objects()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->sprev()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->snext()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->source()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->incident_sface()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->prev()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->next()`\",\n     \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->facet()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sloop()` when accessing `slh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sloop()` when accessing `slh->incident_sface()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sloop()` when accessing `slh->facet()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->center_vertex()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when calling `SD.link_as_face_cycle()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->boundary_entry_objects` using `Edge_of`\",\n     \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when calling `store_sm_boundary_item()` using `Edge_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->boundary_entry_objects` using `SLoop_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when calling `store_sm_boundary_item()` using `SLoop_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->volume()`\"\n  ],\n  \"Impact of exploitation\": \"Arbitrary code execution due to out-of-bounds reads and type confusion. Memory corruption can lead to crashes or potentially allow an attacker to execute malicious code.\",\n  \"Attack vectors\": \"A specially crafted malformed file containing Nef polygon data.\",\n  \"Required attacker capabilities/position\": \"The attacker needs to provide a malicious input file to the vulnerable application or service.\"\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 843 | Access of Resource Using Incompatible Type ('Type Confusion') | Base | Allowed | alternate_terms | 0.700 |\n| 2 | 129 | Improper Validation of Array Index | Variant | Allowed | sparse | 0.890 |\n| 3 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.571 |\n| 4 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.404 |\n| 5 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.381 |\n| 6 | 193 | Off-by-one Error | Base | Allowed | dense | 0.568 |\n| 7 | 476 | NULL Pointer Dereference | Base | Allowed | graph | 0.003 |\n| 8 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.381 |\n| 9 | 197 | Numeric Truncation Error | Base | Allowed | sparse | 0.377 |\n| 10 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.375 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.\n\n### Extended Description\n\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n\n\n### Alternative Terms\nObject Type Confusion\n\n### Relationships\nChildOf -> CWE-704\nChildOf -> CWE-704\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any type-unsafe programming language.\n\n\n**[Research Gap]** \n\nType confusion weaknesses have received some attention by applied researchers and major software vendors for C and C++ code. Some publicly-reported vulnerabilities probably have type confusion as a root-cause weakness, but these may be described as \"memory corruption\" instead.\n\n\nFor other languages, there are very few public reports of type confusion weaknesses. These are probably under-studied. Since many programs rely directly or indirectly on loose typing, a potential \"type confusion\" behavior might be intentional, possibly requiring more manual analysis.\n\n\n\n\n### Observed Examples\n- **CVE-2010-4577:** Type confusion in CSS sequence leads to out-of-bounds read.\n- **CVE-2011-0611:** Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.\n- **CVE-2010-0258:** Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.\n\n\n\n\n## CWE-129: Improper Validation of Array Index\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nout-of-bounds array index\nindex-out-of-range\narray index underflow\n\n### Relationships\nChildOf -> CWE-1285\nChildOf -> CWE-20\nCanPrecede -> CWE-119\nCanPrecede -> CWE-823\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This weakness can precede uncontrolled memory allocation (CWE-789) in languages that automatically expand an array when an index is used that is larger than the size of the array, such as JavaScript.\n\n**[Theoretical]** An improperly validated array index might lead directly to the always-incorrect behavior of \"access of array using out-of-bounds index.\"\n\n\n\n### Observed Examples\n- **CVE-2005-0369:** large ID in packet used as array index\n- **CVE-2001-1009:** negative array index as argument to POP LIST command\n- **CVE-2003-0721:** Integer signedness error leads to negative array index\n\n\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n\n\n\n## CWE-193: Off-by-one Error\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\noff-by-five: An \"off-by-five\" error was reported for sudo in 2002 (CVE-2002-0184), but that is more like a \"length calculation\" error.\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nCanPrecede -> CWE-617\nCanPrecede -> CWE-170\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is not always a buffer overflow. For example, an off-by-one error could be a factor in a partial comparison, a read from the wrong memory location, an incorrect conditional, etc.\n\n\n\n### Observed Examples\n- **CVE-2003-0252:** Off-by-one error allows remote attackers to cause a denial of service and possibly execute arbitrary code via requests that do not contain newlines.\n- **CVE-2001-1391:** Off-by-one vulnerability in driver allows users to modify kernel memory.\n- **CVE-2002-0083:** Off-by-one error allows local users or remote malicious servers to gain privileges.\n\n\n\n\n## CWE-476: NULL Pointer Dereference\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product dereferences a pointer that it expects to be valid but is NULL.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNPD: Common abbreviation for Null Pointer Dereference\nnull deref: Common abbreviation for Null Pointer Dereference\nNPE: Common abbreviation for Null Pointer Exception\nnil pointer dereference: used for access of nil in Go programs\n\n### Relationships\nChildOf -> CWE-710\nChildOf -> CWE-754\nChildOf -> CWE-754\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2005-3274:** race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.\n- **CVE-2002-1912:** large number of packets leads to NULL dereference\n- **CVE-2005-0772:** packet with invalid error status value triggers NULL dereference\n\n\n\n\n## CWE-787: Out-of-bounds Write\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product writes data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMemory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.\n- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.\n- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-197: Numeric Truncation Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTruncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.\n\n### Extended Description\nWhen a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-681\nChildOf -> CWE-681\nChildOf -> CWE-681\nCanAlsoBe -> CWE-195\nCanAlsoBe -> CWE-196\nCanAlsoBe -> CWE-192\nCanAlsoBe -> CWE-194\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** This weakness has traditionally been under-studied and under-reported, although vulnerabilities in popular software have been published in 2008 and 2009.\n\n\n\n### Observed Examples\n- **CVE-2020-17087:** Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.\n- **CVE-2009-0231:** Integer truncation of length value leads to heap-based buffer overflow.\n- **CVE-2008-3282:** Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n",
  "keyphrases": {
    "base_query": "## Vulnerability Description\nMultiple code execution vulnerabilities exists in the Nef polygon-parsing functionality of CGAL libcgal CGAL-5.1.1. A specially crafted malformed file can lead to an **out-of-bounds read** and **type confusion**, which could lead to code execution. An attacker can provide malicious input to trigger any of these vulnerabilities. An oob read vulnerability exists in Nef_S2/SNC_io_parser.h SNC_io_parserread_edge() eh->out_sedge().\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **out-of-bounds read**\n- **weakness:** **type confusion**\n- **impact:** code execution\n- **product:** CGAL libcgal\n- **version:** CGAL-5.1.1\n- **component:** Nef polygon-parsing functionality\n\n## CVE Reference Links Content Summary\n```\n{\n  \"Root cause of vulnerability\": \"Improper validation of array index when parsing Nef polygon data from a file, leading to out-of-bounds reads and type confusion.\",\n  \"Weaknesses/vulnerabilities\": [\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_vertex()` when accessing `Face_of[]`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_vertex()` when accessing `Halfedge_of[]`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_prev()`\",\n     \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_next()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_vertex()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_hedge()` when calling `e->set_face()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_face()` when calling `set_halfedge()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_face()` when calling `store_fc()`\",\n    \"Out-of-bounds read in `Nef_2/PM_io_parser.h` `PM_io_parser::read_face()` when calling `store_iv()`\",\n    \"Out-of-bounds read in `Nef_S2/SM_io_parser.h` `SM_io_parser::read_vertex()` when calling `set_face()`\",\n    \"Out-of-bounds read in `Nef_S2/SM_io_parser.h` `SM_io_parser::read_vertex()` when calling `set_first_out_edge()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->svertices_begin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->svertices_last()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->shalfedges_begin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->shalfedges_last()`\",\n     \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->sfaces_begin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->sfaces_last()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_vertex()` when accessing `vh->shalfloop()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->center_vertex()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->out_sedge()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_edge()` when accessing `eh->incident_sface()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->boundary_entry_objects` using `SEdge_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->boundary_entry_objects` using `SLoop_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_facet()` when accessing `fh->incident_volume()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_volume()` when accessing `ch->shell_entry_objects()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->sprev()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->snext()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->source()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->incident_sface()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->prev()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->next()`\",\n     \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sedge()` when accessing `seh->facet()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sloop()` when accessing `slh->twin()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sloop()` when accessing `slh->incident_sface()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sloop()` when accessing `slh->facet()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->center_vertex()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when calling `SD.link_as_face_cycle()`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->boundary_entry_objects` using `Edge_of`\",\n     \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when calling `store_sm_boundary_item()` using `Edge_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->boundary_entry_objects` using `SLoop_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when calling `store_sm_boundary_item()` using `SLoop_of`\",\n    \"Out-of-bounds read in `Nef_S2/SNC_io_parser.h` `SNC_io_parser::read_sface()` when accessing `sfh->volume()`\"\n  ],\n  \"Impact of exploitation\": \"Arbitrary code execution due to out-of-bounds reads and type confusion. Memory corruption can lead to crashes or potentially allow an attacker to execute malicious code.\",\n  \"Attack vectors\": \"A specially crafted malformed file containing Nef polygon data.\",\n  \"Required attacker capabilities/position\": \"The attacker needs to provide a malicious input file to the vulnerable application or service.\"\n}\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 843 | Access of Resource Using Incompatible Type ('Type Confusion') | Base | Allowed | alternate_terms | 0.700 |\n| 2 | 129 | Improper Validation of Array Index | Variant | Allowed | sparse | 0.890 |\n| 3 | 125 | Out-of-bounds Read | Base | Allowed | sparse | 0.571 |\n| 4 | 190 | Integer Overflow or Wraparound | Base | Allowed | sparse | 0.404 |\n| 5 | 1284 | Improper Validation of Specified Quantity in Input | Base | Allowed | sparse | 0.381 |\n| 6 | 193 | Off-by-one Error | Base | Allowed | dense | 0.568 |\n| 7 | 476 | NULL Pointer Dereference | Base | Allowed | graph | 0.003 |\n| 8 | 787 | Out-of-bounds Write | Base | Allowed | sparse | 0.381 |\n| 9 | 197 | Numeric Truncation Error | Base | Allowed | sparse | 0.377 |\n| 10 | 122 | Heap-based Buffer Overflow | Variant | Allowed | sparse | 0.375 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-843: Access of Resource Using Incompatible Type ('Type Confusion')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.\n\n### Extended Description\n\n\nWhen the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.\n\n\nWhile this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.\n\n\nThis weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.\n\n\n### Alternative Terms\nObject Type Confusion\n\n### Relationships\nChildOf -> CWE-704\nChildOf -> CWE-704\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any type-unsafe programming language.\n\n\n**[Research Gap]** \n\nType confusion weaknesses have received some attention by applied researchers and major software vendors for C and C++ code. Some publicly-reported vulnerabilities probably have type confusion as a root-cause weakness, but these may be described as \"memory corruption\" instead.\n\n\nFor other languages, there are very few public reports of type confusion weaknesses. These are probably under-studied. Since many programs rely directly or indirectly on loose typing, a potential \"type confusion\" behavior might be intentional, possibly requiring more manual analysis.\n\n\n\n\n### Observed Examples\n- **CVE-2010-4577:** Type confusion in CSS sequence leads to out-of-bounds read.\n- **CVE-2011-0611:** Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.\n- **CVE-2010-0258:** Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.\n\n\n\n\n## CWE-129: Improper Validation of Array Index\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nout-of-bounds array index\nindex-out-of-range\narray index underflow\n\n### Relationships\nChildOf -> CWE-1285\nChildOf -> CWE-20\nCanPrecede -> CWE-119\nCanPrecede -> CWE-823\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This weakness can precede uncontrolled memory allocation (CWE-789) in languages that automatically expand an array when an index is used that is larger than the size of the array, such as JavaScript.\n\n**[Theoretical]** An improperly validated array index might lead directly to the always-incorrect behavior of \"access of array using out-of-bounds index.\"\n\n\n\n### Observed Examples\n- **CVE-2005-0369:** large ID in packet used as array index\n- **CVE-2001-1009:** negative array index as argument to POP LIST command\n- **CVE-2003-0721:** Integer signedness error leads to negative array index\n\n\n\n\n## CWE-125: Out-of-bounds Read\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product reads data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOOB read: Shorthand for \"Out of bounds\" read\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1018:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to read 2 bytes past the end of a buffer.\n- **CVE-2020-11899:** Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.\n- **CVE-2014-0160:** Chain: \"Heartbleed\" bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.\n\n\n\n\n## CWE-190: Integer Overflow or Wraparound\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product performs a calculation that can\n         produce an integer overflow or wraparound when the logic\n         assumes that the resulting value will always be larger than\n         the original value. This occurs when an integer value is\n         incremented to a value that is too large to store in the\n         associated representation. When this occurs, the value may\n         become a very small or negative number.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nOverflow: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nWraparound: The terms \"overflow\" and \"wraparound\" are used interchangeably by some people, but they can have more precise distinctions by others. See Terminology Notes.\nwrap, wrap-around, wrap around: Alternate spellings of \"wraparound\"\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nChildOf -> CWE-20\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Be careful of terminology problems with \"overflow,\" \"underflow,\" and \"wraparound\" - see Terminology Notes. Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n**Suggested Alternatives:**\n- CWE-191: Integer Underflow (Wrap or Wraparound). Consider CWE-191 when the result is less than the minimum value that can be represented (sometimes called \"underflows\").\n\n\n### Additional Notes\n**[Relationship]** Integer overflows can be primary to buffer overflows when they cause less memory to be allocated than expected.\n\n**[Terminology]** \n\n\"Integer overflow\" is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.\n\n\nA \"wraparound\" is a well-defined, standard behavior that follows specific rules for how to handle situations when the intended numeric value is too large or too small to be represented, as specified in standards such as C11.\n\n\n\"Overflow\" is sometimes conflated with \"wraparound\" but typically indicates a non-standard or undefined behavior.\n\n\nThe \"overflow\" term is sometimes used to indicate cases where either the maximum or the minimum is exceeded, but others might only use \"overflow\" to indicate exceeding the maximum while using \"underflow\" for exceeding the minimum.\n\n\nSome people use \"overflow\" to mean any value outside the representable range - whether greater than the maximum, or less than the minimum - but CWE uses \"underflow\" for cases in which the intended result is less than the minimum.\n\n\nSee [REF-1440] for additional explanation of the ambiguity of terminology.\n\n\n**[Other]** While there may be circumstances in which the logic intentionally relies on wrapping - such as with modular arithmetic in timers or counters - it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2022-0545:** Chain: 3D renderer has an integer overflow (CWE-190) leading to write-what-where condition (CWE-123) using a crafted image.\n\n\n\n\n## CWE-1284: Improper Validation of Specified Quantity in Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.\n\n### Extended Description\n\n\nSpecified quantities include size, length, frequency, price, rate, number of operations, time, and others. Code may rely on specified quantities to allocate resources, perform calculations, control iteration, etc. When the quantity is not properly validated, then attackers can specify malicious quantities to cause excessive resource allocation, trigger unexpected failures, enable buffer overflows, etc.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\nChildOf -> CWE-20\nCanPrecede -> CWE-789\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2022-21668:** Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).\n- **CVE-2008-1440:** lack of validation of length field leads to infinite loop\n- **CVE-2008-2374:** lack of validation of string length fields allows memory consumption or buffer over-read\n\n\n\n\n## CWE-193: Off-by-one Error\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nA product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\noff-by-five: An \"off-by-five\" error was reported for sudo in 2002 (CVE-2002-0184), but that is more like a \"length calculation\" error.\n\n### Relationships\nChildOf -> CWE-682\nChildOf -> CWE-682\nCanPrecede -> CWE-617\nCanPrecede -> CWE-170\nCanPrecede -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** This is not always a buffer overflow. For example, an off-by-one error could be a factor in a partial comparison, a read from the wrong memory location, an incorrect conditional, etc.\n\n\n\n### Observed Examples\n- **CVE-2003-0252:** Off-by-one error allows remote attackers to cause a denial of service and possibly execute arbitrary code via requests that do not contain newlines.\n- **CVE-2001-1391:** Off-by-one vulnerability in driver allows users to modify kernel memory.\n- **CVE-2002-0083:** Off-by-one error allows local users or remote malicious servers to gain privileges.\n\n\n\n\n## CWE-476: NULL Pointer Dereference\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product dereferences a pointer that it expects to be valid but is NULL.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNPD: Common abbreviation for Null Pointer Dereference\nnull deref: Common abbreviation for Null Pointer Dereference\nNPE: Common abbreviation for Null Pointer Exception\nnil pointer dereference: used for access of nil in Go programs\n\n### Relationships\nChildOf -> CWE-710\nChildOf -> CWE-754\nChildOf -> CWE-754\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2005-3274:** race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference; also involves locking.\n- **CVE-2002-1912:** large number of packets leads to NULL dereference\n- **CVE-2005-0772:** packet with invalid error status value triggers NULL dereference\n\n\n\n\n## CWE-787: Out-of-bounds Write\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product writes data past the end, or before the beginning, of the intended buffer.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMemory Corruption: Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is otherwise invalid.\n\n### Relationships\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\nChildOf -> CWE-119\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2023-1017:** The reference implementation code for a Trusted Platform Module does not implement length checks on data, allowing for an attacker to write 2 bytes past the end of a buffer.\n- **CVE-2021-21220:** Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.\n- **CVE-2021-28664:** GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-197: Numeric Truncation Error\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nTruncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.\n\n### Extended Description\nWhen a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-681\nChildOf -> CWE-681\nChildOf -> CWE-681\nCanAlsoBe -> CWE-195\nCanAlsoBe -> CWE-196\nCanAlsoBe -> CWE-192\nCanAlsoBe -> CWE-194\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Research Gap]** This weakness has traditionally been under-studied and under-reported, although vulnerabilities in popular software have been published in 2008 and 2009.\n\n\n\n### Observed Examples\n- **CVE-2020-17087:** Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.\n- **CVE-2009-0231:** Integer truncation of length value leads to heap-based buffer overflow.\n- **CVE-2008-3282:** Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.\n\n\n\n\n## CWE-122: Heap-based Buffer Overflow\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nA heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-788\nChildOf -> CWE-787\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.\n\n\n\n### Observed Examples\n- **CVE-2021-43537:** Chain: in a web browser, an unsigned 64-bit integer is forcibly cast to a 32-bit integer (CWE-681) and potentially leading to an integer overflow (CWE-190). If an integer overflow occurs, this can cause heap memory corruption (CWE-122)\n- **CVE-2007-4268:** Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122)\n- **CVE-2009-2523:** Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).\n\n"
  },
  "timestamp": "2025-04-02 10:50:27",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "197",
      "name": "Numeric Truncation Error",
      "type": "Base",
      "score": 0.786658189396972
    },
    {
      "cwe_id": "129",
      "name": "Improper Validation of Array Index",
      "type": "Variant",
      "score": 0.7843288009334096
    },
    {
      "cwe_id": "191",
      "name": "Integer Underflow (Wrap or Wraparound)",
      "type": "Base",
      "score": 0.7837439309974712
    },
    {
      "cwe_id": "681",
      "name": "Incorrect Conversion between Numeric Types",
      "type": "Base",
      "score": 0.780228042578289
    },
    {
      "cwe_id": "131",
      "name": "Incorrect Calculation of Buffer Size",
      "type": "Base",
      "score": 0.770143882246876
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "Base",
      "score": 0.7616433272966546
    },
    {
      "cwe_id": "125",
      "name": "Out-of-bounds Read",
      "type": "Base",
      "score": 0.7612073488324416
    },
    {
      "cwe_id": "193",
      "name": "Off-by-one Error",
      "type": "Base",
      "score": 0.7516861079475513
    },
    {
      "cwe_id": "126",
      "name": "Buffer Over-read",
      "type": "Variant",
      "score": 0.7480082401382818
    },
    {
      "cwe_id": "805",
      "name": "Buffer Access with Incorrect Length Value",
      "type": "Base",
      "score": 0.7452538070360759
    }
  ]
}