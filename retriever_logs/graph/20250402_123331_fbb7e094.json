{
  "retriever": "graph",
  "query": "## Vulnerability Description\nA **code injection** vulnerability exists in Pulse Connect Secure <9.1R8 that allows an attacker to crafted a URI to perform an arbitrary code execution via the admin web interface.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input sanitization**\n- **weakness:** **code injection**\n- **impact:** remote code execution\n- **vector:** crafted URI\n- **attacker:** attacker\n- **product:** Pulse Connect Secure\n- **version:** <9.1R8\n- **component:** admin web interface\n\n## CVE Reference Links Content Summary\nThe provided content discusses multiple vulnerabilities in Pulse Connect Secure, including CVE-2020-8218, and provides detailed technical information about their exploitation.\n\n**CVE-2020-8218**\n\n*   **Root Cause:** Command injection vulnerability in the `downloadlicenses.cgi` file of the admin portal. Specifically, the `$authCode` variable, which is user-controlled, is directly incorporated into a system command.\n*   **Weaknesses:**\n    *   Unsanitized user input: The `authCode` variable is not properly sanitized before being used in a system call, allowing command injection.\n    *   Use of system(): The use of the `system()` function without adequate input validation opens the door to command execution.\n*   **Impact:** Remote code execution. An attacker can execute arbitrary commands on the system with the privileges of the web server.\n*   **Attack Vector:** The vulnerability can be exploited by sending a specially crafted request to `downloadlicenses.cgi` with malicious input for the `$authCode` parameter.\n*   **Required Attacker Capabilities:**\n    *   Requires admin-level authentication to access the vulnerable endpoint.\n\nThe document also discusses three other vulnerabilities:\n\n**CVE-2020-8238:**\n\n*   **Root Cause:** Reflected XSS in the `launch.cgi` endpoint. The URL parameter is directly reflected in the HTTP response without sanitization.\n*   **Weaknesses:**\n    *   Lack of input sanitization: The URL parameter is not sanitized or validated before being included in the server's response, making it vulnerable to XSS.\n    *   Conditional payload execution: The vulnerability is only triggered when a colon (:) character is present in the URL parameter, due to a check related to web bookmarks.\n*  **Impact:** Session hijacking. An attacker can steal the session cookie of an authenticated user.\n*  **Attack Vector:** Sending a specially crafted URL with a malicious payload within the `url` parameter. The malicious URL is triggered when the user clicks on it, redirecting the browser to an attacker-controlled site and sending the session cookie.\n* **Required Attacker Capabilities:** An unauthenticated attacker can trick an authenticated admin into clicking a malicious link.\n\n**CVE-2020-8256:**\n\n*   **Root Cause:** XML External Entity (XXE) injection in the admin dashboard when processing user-supplied teleconference bridge profiles.\n*   **Weaknesses:**\n    *   Lack of input sanitization: The XML templates provided by the user are not properly validated for external entities.\n    *   Vulnerable XML parser: The parser allows the inclusion of external entities, making it vulnerable to XXE attacks.\n*   **Impact:** Arbitrary file read. An attacker can read files on the remote filesystem.\n*   **Attack Vector:** Uploading a malicious XML template containing an XXE payload and then viewing the template within the admin dashboard.\n*   **Required Attacker Capabilities:** Authenticated user access to the admin dashboard.\n\n**XSS through command injection in downloadlicenses.cgi:**\n\n*   **Root Cause:** Reflected XSS in the `downloadlicenses.cgi` endpoint. The server directly outputs URL parameters, which a malicious user can control, on the page when the license code is incorrect.\n*    **Weaknesses:**\n        *   Lack of output sanitization: URL parameters are directly printed to the output without proper encoding, leading to XSS.\n*   **Impact:** Session hijacking. An attacker can steal the session cookie of an admin.\n*   **Attack Vector:** By crafting a malicious URL that includes javascript code within the `txtVLSAuthCode` parameter and tricking the admin into accessing the URL.\n*   **Required Attacker Capabilities:** An unauthenticated attacker can trick an authenticated admin into clicking a malicious link.\n\nThe document also details how the researchers extracted the source code from the appliance using a memory manipulation technique.\n\nThis content provides a good amount of detail for CVE-2020-8218, especially compared to the placeholder CVE description.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 138 | Improper Neutralization of Special Elements | Class | Discouraged | sparse | 0.207 |\n| 2 | 1336 | Improper Neutralization of Special Elements Used in a Template Engine | Base | Allowed | sparse | 0.200 |\n| 3 | 94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | sparse | 0.200 |\n| 4 | 434 | Unrestricted Upload of File with Dangerous Type | Base | Allowed | sparse | 0.199 |\n| 5 | 78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | sparse | 0.197 |\n| 6 | 96 | Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection') | Base | Allowed | dense | 0.631 |\n| 7 | 73 | External Control of File Name or Path | Base | Allowed | graph | 0.003 |\n| 8 | 20 | Improper Input Validation | Class | Discouraged | sparse | 0.185 |\n| 9 | 611 | Improper Restriction of XML External Entity Reference | Base | Allowed | sparse | 0.183 |\n| 10 | 134 | Use of Externally-Controlled Format String | Base | Allowed | sparse | 0.180 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-138: Improper Neutralization of Special Elements\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.\n\n### Extended Description\nMost languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If product does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (\"less than\") as meaning \"read input from a file\".\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness can be related to interpretation conflicts or interaction errors in intermediaries (such as proxies or application firewalls) when the intermediary's model of an endpoint does not account for protocol-specific special elements.\n\n**[Relationship]** See this entry's children for different types of special elements that have been observed at one point or another. However, it can be difficult to find suitable CVE examples. In an attempt to be complete, CWE includes some types that do not have any associated observed example.\n\n**[Research Gap]** This weakness is probably under-studied for proprietary or custom formats. It is likely that these issues are fairly common in applications that use their own custom format for configuration files, logs, meta-data, messaging, etc. They would only be found by accident or with a focused effort based on an understanding of the format.\n\n\n\n### Observed Examples\n- **CVE-2001-0677:** Read arbitrary files from mail client by providing a special MIME header that is internally used to store pathnames for attachments.\n- **CVE-2000-0703:** Setuid program does not cleanse special escape sequence before sending data to a mail program, causing the mail program to process those sequences.\n- **CVE-2003-0020:** Multi-channel issue. Terminal escape sequences not filtered from log files.\n\n\n\n\n## CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product uses a template engine to insert or process externally-influenced input, but it does not neutralize or incorrectly neutralizes special elements or syntax that can be interpreted as template expressions or other code directives when processed by the engine.\n\n### Extended Description\n\n\nMany web applications use template engines that allow developers to insert externally-influenced values into free text or messages in order to generate a full web page, document, message, etc. Such engines include Twig, Jinja2, Pug, Java Server Pages, FreeMarker, Velocity, ColdFusion, Smarty, and many others - including PHP itself. Some CMS (Content Management Systems) also use templates.\n\n\nTemplate engines often have their own custom command or expression language. If an attacker can influence input into a template before it is processed, then the attacker can invoke arbitrary expressions, i.e. perform injection attacks. For example, in some template languages, an attacker could inject the expression \"{{7*7}}\" and determine if the output returns \"49\" instead. The syntax varies depending on the language.\n\n\nIn some cases, XSS-style attacks can work, which can obscure the root cause if the developer does not closely investigate the root cause of the error.\n\n\nTemplate engines can be used on the server or client, so both \"sides\" could be affected by injection. The mechanisms of attack or the affected technologies might be different, but the mistake is fundamentally the same.\n\n\n### Alternative Terms\nServer-Side Template Injection / SSTI: This term is used for injection into template engines being used by a server.\nClient-Side Template Injection / CSTI: This term is used for injection into template engines being used by a client.\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Since expression languages are often used in templating languages, there may be some overlap with CWE-917 (Expression Language Injection). XSS (CWE-79) is also co-located with template injection.\n\n**[Maintenance]** The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified.\n\n\n\n### Observed Examples\n- **CVE-2024-34359:** Chain: Python bindings for LLM library do not use a sandboxed environment when parsing a template and constructing a prompt, allowing jinja2 Server Side Template Injection and code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2017-16783:** server-side template injection in content management server\n- **CVE-2020-9437:** authentication / identity management product has client-side template injection\n\n\n\n\n## CWE-94: Improper Control of Generation of Code ('Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.\n\n### Extended Description\n\n\nWhen a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution.\n\n\nInjection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nChildOf -> CWE-913\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This entry is frequently misused for vulnerabilities with a technical impact of \"code execution,\" which does not by itself indicate a root cause weakness, since dozens of weaknesses can enable code execution.\n**Comments:** This weakness only applies when the product's functionality intentionally constructs all or part of a code segment. It could be that executing code could be the result of other weaknesses that do not involve the construction of code segments.\n**Reasons:**\n- Frequent Misuse\n- Frequent Misinterpretation\n\n\n\n### Observed Examples\n- **CVE-2023-29374:** Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-5565:** Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n\n\n\n\n## CWE-434: Unrestricted Upload of File with Dangerous Type\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product allows the upload or transfer of dangerous file types that are automatically processed within its environment.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nUnrestricted File Upload: Used in vulnerability databases and elsewhere, but it is insufficiently precise. The phrase could be interpreted as the lack of restrictions on the size or number of uploaded files, which is a resource consumption issue.\n\n### Relationships\nChildOf -> CWE-669\nChildOf -> CWE-669\nPeerOf -> CWE-351\nPeerOf -> CWE-436\nPeerOf -> CWE-430\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThis can have a chaining relationship with incomplete denylist / permissive allowlist errors when the product tries, but fails, to properly limit which types of files are allowed (CWE-183, CWE-184).\n\n\nThis can also overlap multiple interpretation errors for intermediaries, e.g. anti-virus products that do not remove or quarantine attachments with certain file extensions that can be processed by client systems.\n\n\n\n\n### Observed Examples\n- **CVE-2023-5227:** PHP-based FAQ management app does not check the MIME type for uploaded images\n- **CVE-2001-0901:** Web-based mail product stores \".shtml\" attachments that could contain SSI\n- **CVE-2002-1841:** PHP upload does not restrict file types\n\n\n\n\n## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n### Extended Description\n\n\nThis weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.\n\n\nThere are at least two subtypes of OS command injection:\n\n\n  - The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.\n\n  - The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.\n\nFrom a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.\n\n### Alternative Terms\nShell injection\nShell metacharacters\nOS Command Injection\n\n### Relationships\nChildOf -> CWE-77\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\nCanAlsoBe -> CWE-88\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** The \"OS command injection\" phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an \"-exec\" switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX \"find\" command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.\n\n**[Research Gap]** More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.\n\n\n\n### Observed Examples\n- **CVE-2020-10987:** OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.\n- **CVE-2020-10221:** Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.\n- **CVE-2020-9054:** Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \"HTML injection\" (see CWE-79: XSS) could be thought of as an example of this, but the code is injected and executed on the client side, not the server side. Server-Side Includes (SSI) are an example of direct static code injection.\n\n\n\n### Observed Examples\n- **CVE-2002-0495:** Perl code directly injected into CGI library file from parameters to another CGI program.\n- **CVE-2005-1876:** Direct PHP code injection into supporting template file.\n- **CVE-2005-1894:** Direct code injection into PHP script that can be accessed by attacker.\n\n\n\n\n## CWE-73: External Control of File Name or Path\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product allows user input to control or influence paths or file names that are used in filesystem operations.\n\n### Extended Description\n\n\nThis could allow an attacker to access or modify system files or other files that are critical to the application.\n\n\nPath manipulation errors occur when the following two conditions are met:\n\n```\n\t\t1. An attacker can specify a path used in an operation on the filesystem.\n\t\t2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n```\nFor example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-642\nChildOf -> CWE-610\nChildOf -> CWE-20\nCanPrecede -> CWE-22\nCanPrecede -> CWE-41\nCanPrecede -> CWE-98\nCanPrecede -> CWE-434\nCanPrecede -> CWE-59\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** CWE-114 is a Class, but it is listed a child of CWE-73 in view 1000. This suggests some abstraction problems that should be resolved in future versions.\n\n**[Relationship]** \n\nThe external control of filenames can be the primary link in chains with other file-related weaknesses, as seen in the CanPrecede relationships. This is because software systems use files for many different purposes: to execute programs, load code libraries, to store application data, to store configuration settings, record temporary data, act as signals or semaphores to other processes, etc.\n\n\nHowever, those weaknesses do not always require external control. For example, link-following weaknesses (CWE-59) often involve pathnames that are not controllable by the attacker at all.\n\n\nThe external control can be resultant from other issues. For example, in PHP applications, the register_globals setting can allow an attacker to modify variables that the programmer thought were immutable, enabling file inclusion (CWE-98) and path traversal (CWE-22). Operating with excessive privileges (CWE-250) might allow an attacker to specify an input filename that is not directly readable by the attacker, but is accessible to the privileged program. A buffer overflow (CWE-119) might give an attacker control over nearby memory locations that are related to pathnames, but were not directly modifiable by the attacker.\n\n\n\n\n### Observed Examples\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2008-5748:** Chain: external control of values for user's desired language and theme enables path traversal.\n- **CVE-2008-5764:** Chain: external control of user's target language enables remote file inclusion.\n\n\n\n\n## CWE-20: Improper Input Validation\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.\n\n### Extended Description\n\n\nInput validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.\n\n\nInput validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.)\n\n\nInput validation can be applied to:\n\n\n  - raw data - strings, numbers, parameters, file contents, etc.\n\n  - metadata - information about the raw data, such as headers or size\n\nData can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data.\n\nMany properties of raw data or metadata may need to be validated upon entry into the code, such as:\n\n\n  - specified quantities such as size, length, frequency, price, rate, number of operations, time, etc.\n\n  - implied or derived quantities, such as the actual size of a file instead of a specified size\n\n  - indexes, offsets, or positions into more complex data structures\n\n  - symbolic keys or other elements into hash tables, associative arrays, etc.\n\n  - well-formedness, i.e. syntactic correctness - compliance with expected syntax \n\n  - lexical token correctness - compliance with rules for what is treated as a token\n\n  - specified or derived type - the actual type of the input (or what the input appears to be)\n\n  - consistency - between individual data elements, between raw data and metadata, between references, etc.\n\n  - conformance to domain-specific rules, e.g. business logic \n\n  - equivalence - ensuring that equivalent inputs are treated the same\n\n  - authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data\n\nImplied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. \n\nNote that \"input validation\" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation.\n\n\nFinally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\nPeerOf -> CWE-345\nCanPrecede -> CWE-22\nCanPrecede -> CWE-41\nCanPrecede -> CWE-74\nCanPrecede -> CWE-119\nCanPrecede -> CWE-770\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-20 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available [REF-1287]. It is not useful for trend analysis. It is also a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Consider lower-level children such as Improper Use of Validation Framework (CWE-1173) or improper validation involving specific types or properties of input such as Specified Quantity (CWE-1284); Specified Index, Position, or Offset (CWE-1285); Syntactic Correctness (CWE-1286); Specified Type (CWE-1287); Consistency within Input (CWE-1288); or Unsafe Equivalence (CWE-1289).\n**Reasons:**\n- Frequent Misuse\n**Suggested Alternatives:**\n- CWE-1284: Specified Quantity\n- CWE-1285: Specified Index, Position, or Offset\n- CWE-1286: Syntactic Correctness\n- CWE-1287: Specified Type\n- CWE-1288: Consistency within Input\n- CWE-1289: Unsafe Equivalence\n- CWE-116: Improper Encoding or Escaping of Output\n\n\n### Additional Notes\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\n**[Maintenance]** As of 2020, this entry is used more often than preferred, and it is a source of frequent confusion. It is being actively modified for CWE 4.1 and subsequent versions.\n\n**[Maintenance]** Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document.\n\n**[Maintenance]** Input validation - whether missing or incorrect - is such an essential and widespread part of secure development that it is implicit in many different weaknesses. Traditionally, problems such as buffer overflows and XSS have been classified as input validation problems by many security professionals. However, input validation is not necessarily the only protection mechanism available for avoiding such problems, and in some cases it is not even sufficient. The CWE team has begun capturing these subtleties in chains within the Research Concepts view (CWE-1000), but more work is needed.\n\n**[Terminology]** \n\nThe \"input validation\" term is extremely common, but it is used in many different ways. In some cases its usage can obscure the real underlying weakness or otherwise hide chaining and composite relationships.\n\n\nSome people use \"input validation\" as a general term that covers many different neutralization techniques for ensuring that input is appropriate, such as filtering, canonicalization, and escaping. Others use the term in a more narrow context to simply mean \"checking if an input conforms to expectations without changing it.\" CWE uses this more narrow interpretation.\n\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2021-30860:** Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-611: Improper Restriction of XML External Entity Reference\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.\n\n### Extended Description\n\n\nXML documents optionally contain a Document Type Definition (DTD), which, among other features, enables the definition of XML entities. It is possible to define an entity by providing a substitution string in the form of a URI. The XML parser can access the contents of this URI and embed these contents back into the XML document for further processing.\n\n\nBy submitting an XML file that defines an external entity with a file:// URI, an attacker can cause the processing application to read the contents of a local file. For example, a URI such as \"file:///c:/winnt/win.ini\" designates (in Windows) the file C:\\Winnt\\win.ini, or file:///etc/passwd designates the password file in Unix-based systems. Using URIs with other schemes such as http://, the attacker can force the application to make outgoing requests to servers that the attacker cannot reach directly, which can be used to bypass firewall restrictions or hide the source of attacks such as port scanning.\n\n\nOnce the content of the URI is read, it is fed back into the application that is processing the XML. This application may echo back the data (e.g. in an error message), thereby exposing the file contents.\n\n\n### Alternative Terms\nXXE: An acronym used for the term \"XML eXternal Entities\"\n\n### Relationships\nChildOf -> CWE-610\nChildOf -> CWE-610\nPeerOf -> CWE-441\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2022-42745:** Recruiter software allows reading arbitrary files using XXE\n- **CVE-2005-1306:** A browser control can allow remote attackers to determine the existence of files via Javascript containing XML script.\n- **CVE-2012-5656:** XXE during SVG image conversion\n\n\n\n\n## CWE-134: Use of Externally-Controlled Format String\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source.\n\n### Extended Description\n\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-668\nChildOf -> CWE-668\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any programming language that support format strings.\n\n\n**[Other]** \n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n\n\n**[Research Gap]** Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.\n\n\n\n### Observed Examples\n- **CVE-2002-1825:** format string in Perl program\n- **CVE-2001-0717:** format string in bad call to syslog function\n- **CVE-2002-0573:** format string in bad call to syslog function\n\n Consider specifically these CWEs: CWE-1336 CWE-88 CWE-73 CWE-134 CWE-138 CWE-74 CWE-116 CWE-22 CWE-184",
  "keyphrases": {
    "original_query": "## Vulnerability Description\nA **code injection** vulnerability exists in Pulse Connect Secure <9.1R8 that allows an attacker to crafted a URI to perform an arbitrary code execution via the admin web interface.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input sanitization**\n- **weakness:** **code injection**\n- **impact:** remote code execution\n- **vector:** crafted URI\n- **attacker:** attacker\n- **product:** Pulse Connect Secure\n- **version:** <9.1R8\n- **component:** admin web interface\n\n## CVE Reference Links Content Summary\nThe provided content discusses multiple vulnerabilities in Pulse Connect Secure, including CVE-2020-8218, and provides detailed technical information about their exploitation.\n\n**CVE-2020-8218**\n\n*   **Root Cause:** Command injection vulnerability in the `downloadlicenses.cgi` file of the admin portal. Specifically, the `$authCode` variable, which is user-controlled, is directly incorporated into a system command.\n*   **Weaknesses:**\n    *   Unsanitized user input: The `authCode` variable is not properly sanitized before being used in a system call, allowing command injection.\n    *   Use of system(): The use of the `system()` function without adequate input validation opens the door to command execution.\n*   **Impact:** Remote code execution. An attacker can execute arbitrary commands on the system with the privileges of the web server.\n*   **Attack Vector:** The vulnerability can be exploited by sending a specially crafted request to `downloadlicenses.cgi` with malicious input for the `$authCode` parameter.\n*   **Required Attacker Capabilities:**\n    *   Requires admin-level authentication to access the vulnerable endpoint.\n\nThe document also discusses three other vulnerabilities:\n\n**CVE-2020-8238:**\n\n*   **Root Cause:** Reflected XSS in the `launch.cgi` endpoint. The URL parameter is directly reflected in the HTTP response without sanitization.\n*   **Weaknesses:**\n    *   Lack of input sanitization: The URL parameter is not sanitized or validated before being included in the server's response, making it vulnerable to XSS.\n    *   Conditional payload execution: The vulnerability is only triggered when a colon (:) character is present in the URL parameter, due to a check related to web bookmarks.\n*  **Impact:** Session hijacking. An attacker can steal the session cookie of an authenticated user.\n*  **Attack Vector:** Sending a specially crafted URL with a malicious payload within the `url` parameter. The malicious URL is triggered when the user clicks on it, redirecting the browser to an attacker-controlled site and sending the session cookie.\n* **Required Attacker Capabilities:** An unauthenticated attacker can trick an authenticated admin into clicking a malicious link.\n\n**CVE-2020-8256:**\n\n*   **Root Cause:** XML External Entity (XXE) injection in the admin dashboard when processing user-supplied teleconference bridge profiles.\n*   **Weaknesses:**\n    *   Lack of input sanitization: The XML templates provided by the user are not properly validated for external entities.\n    *   Vulnerable XML parser: The parser allows the inclusion of external entities, making it vulnerable to XXE attacks.\n*   **Impact:** Arbitrary file read. An attacker can read files on the remote filesystem.\n*   **Attack Vector:** Uploading a malicious XML template containing an XXE payload and then viewing the template within the admin dashboard.\n*   **Required Attacker Capabilities:** Authenticated user access to the admin dashboard.\n\n**XSS through command injection in downloadlicenses.cgi:**\n\n*   **Root Cause:** Reflected XSS in the `downloadlicenses.cgi` endpoint. The server directly outputs URL parameters, which a malicious user can control, on the page when the license code is incorrect.\n*    **Weaknesses:**\n        *   Lack of output sanitization: URL parameters are directly printed to the output without proper encoding, leading to XSS.\n*   **Impact:** Session hijacking. An attacker can steal the session cookie of an admin.\n*   **Attack Vector:** By crafting a malicious URL that includes javascript code within the `txtVLSAuthCode` parameter and tricking the admin into accessing the URL.\n*   **Required Attacker Capabilities:** An unauthenticated attacker can trick an authenticated admin into clicking a malicious link.\n\nThe document also details how the researchers extracted the source code from the appliance using a memory manipulation technique.\n\nThis content provides a good amount of detail for CVE-2020-8218, especially compared to the placeholder CVE description.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 138 | Improper Neutralization of Special Elements | Class | Discouraged | sparse | 0.207 |\n| 2 | 1336 | Improper Neutralization of Special Elements Used in a Template Engine | Base | Allowed | sparse | 0.200 |\n| 3 | 94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | sparse | 0.200 |\n| 4 | 434 | Unrestricted Upload of File with Dangerous Type | Base | Allowed | sparse | 0.199 |\n| 5 | 78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | sparse | 0.197 |\n| 6 | 96 | Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection') | Base | Allowed | dense | 0.631 |\n| 7 | 73 | External Control of File Name or Path | Base | Allowed | graph | 0.003 |\n| 8 | 20 | Improper Input Validation | Class | Discouraged | sparse | 0.185 |\n| 9 | 611 | Improper Restriction of XML External Entity Reference | Base | Allowed | sparse | 0.183 |\n| 10 | 134 | Use of Externally-Controlled Format String | Base | Allowed | sparse | 0.180 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-138: Improper Neutralization of Special Elements\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.\n\n### Extended Description\nMost languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If product does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (\"less than\") as meaning \"read input from a file\".\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness can be related to interpretation conflicts or interaction errors in intermediaries (such as proxies or application firewalls) when the intermediary's model of an endpoint does not account for protocol-specific special elements.\n\n**[Relationship]** See this entry's children for different types of special elements that have been observed at one point or another. However, it can be difficult to find suitable CVE examples. In an attempt to be complete, CWE includes some types that do not have any associated observed example.\n\n**[Research Gap]** This weakness is probably under-studied for proprietary or custom formats. It is likely that these issues are fairly common in applications that use their own custom format for configuration files, logs, meta-data, messaging, etc. They would only be found by accident or with a focused effort based on an understanding of the format.\n\n\n\n### Observed Examples\n- **CVE-2001-0677:** Read arbitrary files from mail client by providing a special MIME header that is internally used to store pathnames for attachments.\n- **CVE-2000-0703:** Setuid program does not cleanse special escape sequence before sending data to a mail program, causing the mail program to process those sequences.\n- **CVE-2003-0020:** Multi-channel issue. Terminal escape sequences not filtered from log files.\n\n\n\n\n## CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product uses a template engine to insert or process externally-influenced input, but it does not neutralize or incorrectly neutralizes special elements or syntax that can be interpreted as template expressions or other code directives when processed by the engine.\n\n### Extended Description\n\n\nMany web applications use template engines that allow developers to insert externally-influenced values into free text or messages in order to generate a full web page, document, message, etc. Such engines include Twig, Jinja2, Pug, Java Server Pages, FreeMarker, Velocity, ColdFusion, Smarty, and many others - including PHP itself. Some CMS (Content Management Systems) also use templates.\n\n\nTemplate engines often have their own custom command or expression language. If an attacker can influence input into a template before it is processed, then the attacker can invoke arbitrary expressions, i.e. perform injection attacks. For example, in some template languages, an attacker could inject the expression \"{{7*7}}\" and determine if the output returns \"49\" instead. The syntax varies depending on the language.\n\n\nIn some cases, XSS-style attacks can work, which can obscure the root cause if the developer does not closely investigate the root cause of the error.\n\n\nTemplate engines can be used on the server or client, so both \"sides\" could be affected by injection. The mechanisms of attack or the affected technologies might be different, but the mistake is fundamentally the same.\n\n\n### Alternative Terms\nServer-Side Template Injection / SSTI: This term is used for injection into template engines being used by a server.\nClient-Side Template Injection / CSTI: This term is used for injection into template engines being used by a client.\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Since expression languages are often used in templating languages, there may be some overlap with CWE-917 (Expression Language Injection). XSS (CWE-79) is also co-located with template injection.\n\n**[Maintenance]** The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified.\n\n\n\n### Observed Examples\n- **CVE-2024-34359:** Chain: Python bindings for LLM library do not use a sandboxed environment when parsing a template and constructing a prompt, allowing jinja2 Server Side Template Injection and code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2017-16783:** server-side template injection in content management server\n- **CVE-2020-9437:** authentication / identity management product has client-side template injection\n\n\n\n\n## CWE-94: Improper Control of Generation of Code ('Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.\n\n### Extended Description\n\n\nWhen a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution.\n\n\nInjection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nChildOf -> CWE-913\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This entry is frequently misused for vulnerabilities with a technical impact of \"code execution,\" which does not by itself indicate a root cause weakness, since dozens of weaknesses can enable code execution.\n**Comments:** This weakness only applies when the product's functionality intentionally constructs all or part of a code segment. It could be that executing code could be the result of other weaknesses that do not involve the construction of code segments.\n**Reasons:**\n- Frequent Misuse\n- Frequent Misinterpretation\n\n\n\n### Observed Examples\n- **CVE-2023-29374:** Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-5565:** Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n\n\n\n\n## CWE-434: Unrestricted Upload of File with Dangerous Type\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product allows the upload or transfer of dangerous file types that are automatically processed within its environment.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nUnrestricted File Upload: Used in vulnerability databases and elsewhere, but it is insufficiently precise. The phrase could be interpreted as the lack of restrictions on the size or number of uploaded files, which is a resource consumption issue.\n\n### Relationships\nChildOf -> CWE-669\nChildOf -> CWE-669\nPeerOf -> CWE-351\nPeerOf -> CWE-436\nPeerOf -> CWE-430\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThis can have a chaining relationship with incomplete denylist / permissive allowlist errors when the product tries, but fails, to properly limit which types of files are allowed (CWE-183, CWE-184).\n\n\nThis can also overlap multiple interpretation errors for intermediaries, e.g. anti-virus products that do not remove or quarantine attachments with certain file extensions that can be processed by client systems.\n\n\n\n\n### Observed Examples\n- **CVE-2023-5227:** PHP-based FAQ management app does not check the MIME type for uploaded images\n- **CVE-2001-0901:** Web-based mail product stores \".shtml\" attachments that could contain SSI\n- **CVE-2002-1841:** PHP upload does not restrict file types\n\n\n\n\n## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n### Extended Description\n\n\nThis weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.\n\n\nThere are at least two subtypes of OS command injection:\n\n\n  - The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.\n\n  - The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.\n\nFrom a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.\n\n### Alternative Terms\nShell injection\nShell metacharacters\nOS Command Injection\n\n### Relationships\nChildOf -> CWE-77\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\nCanAlsoBe -> CWE-88\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** The \"OS command injection\" phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an \"-exec\" switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX \"find\" command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.\n\n**[Research Gap]** More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.\n\n\n\n### Observed Examples\n- **CVE-2020-10987:** OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.\n- **CVE-2020-10221:** Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.\n- **CVE-2020-9054:** Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \"HTML injection\" (see CWE-79: XSS) could be thought of as an example of this, but the code is injected and executed on the client side, not the server side. Server-Side Includes (SSI) are an example of direct static code injection.\n\n\n\n### Observed Examples\n- **CVE-2002-0495:** Perl code directly injected into CGI library file from parameters to another CGI program.\n- **CVE-2005-1876:** Direct PHP code injection into supporting template file.\n- **CVE-2005-1894:** Direct code injection into PHP script that can be accessed by attacker.\n\n\n\n\n## CWE-73: External Control of File Name or Path\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product allows user input to control or influence paths or file names that are used in filesystem operations.\n\n### Extended Description\n\n\nThis could allow an attacker to access or modify system files or other files that are critical to the application.\n\n\nPath manipulation errors occur when the following two conditions are met:\n\n```\n\t\t1. An attacker can specify a path used in an operation on the filesystem.\n\t\t2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n```\nFor example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-642\nChildOf -> CWE-610\nChildOf -> CWE-20\nCanPrecede -> CWE-22\nCanPrecede -> CWE-41\nCanPrecede -> CWE-98\nCanPrecede -> CWE-434\nCanPrecede -> CWE-59\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** CWE-114 is a Class, but it is listed a child of CWE-73 in view 1000. This suggests some abstraction problems that should be resolved in future versions.\n\n**[Relationship]** \n\nThe external control of filenames can be the primary link in chains with other file-related weaknesses, as seen in the CanPrecede relationships. This is because software systems use files for many different purposes: to execute programs, load code libraries, to store application data, to store configuration settings, record temporary data, act as signals or semaphores to other processes, etc.\n\n\nHowever, those weaknesses do not always require external control. For example, link-following weaknesses (CWE-59) often involve pathnames that are not controllable by the attacker at all.\n\n\nThe external control can be resultant from other issues. For example, in PHP applications, the register_globals setting can allow an attacker to modify variables that the programmer thought were immutable, enabling file inclusion (CWE-98) and path traversal (CWE-22). Operating with excessive privileges (CWE-250) might allow an attacker to specify an input filename that is not directly readable by the attacker, but is accessible to the privileged program. A buffer overflow (CWE-119) might give an attacker control over nearby memory locations that are related to pathnames, but were not directly modifiable by the attacker.\n\n\n\n\n### Observed Examples\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2008-5748:** Chain: external control of values for user's desired language and theme enables path traversal.\n- **CVE-2008-5764:** Chain: external control of user's target language enables remote file inclusion.\n\n\n\n\n## CWE-20: Improper Input Validation\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.\n\n### Extended Description\n\n\nInput validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.\n\n\nInput validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.)\n\n\nInput validation can be applied to:\n\n\n  - raw data - strings, numbers, parameters, file contents, etc.\n\n  - metadata - information about the raw data, such as headers or size\n\nData can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data.\n\nMany properties of raw data or metadata may need to be validated upon entry into the code, such as:\n\n\n  - specified quantities such as size, length, frequency, price, rate, number of operations, time, etc.\n\n  - implied or derived quantities, such as the actual size of a file instead of a specified size\n\n  - indexes, offsets, or positions into more complex data structures\n\n  - symbolic keys or other elements into hash tables, associative arrays, etc.\n\n  - well-formedness, i.e. syntactic correctness - compliance with expected syntax \n\n  - lexical token correctness - compliance with rules for what is treated as a token\n\n  - specified or derived type - the actual type of the input (or what the input appears to be)\n\n  - consistency - between individual data elements, between raw data and metadata, between references, etc.\n\n  - conformance to domain-specific rules, e.g. business logic \n\n  - equivalence - ensuring that equivalent inputs are treated the same\n\n  - authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data\n\nImplied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. \n\nNote that \"input validation\" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation.\n\n\nFinally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\nPeerOf -> CWE-345\nCanPrecede -> CWE-22\nCanPrecede -> CWE-41\nCanPrecede -> CWE-74\nCanPrecede -> CWE-119\nCanPrecede -> CWE-770\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-20 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available [REF-1287]. It is not useful for trend analysis. It is also a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Consider lower-level children such as Improper Use of Validation Framework (CWE-1173) or improper validation involving specific types or properties of input such as Specified Quantity (CWE-1284); Specified Index, Position, or Offset (CWE-1285); Syntactic Correctness (CWE-1286); Specified Type (CWE-1287); Consistency within Input (CWE-1288); or Unsafe Equivalence (CWE-1289).\n**Reasons:**\n- Frequent Misuse\n**Suggested Alternatives:**\n- CWE-1284: Specified Quantity\n- CWE-1285: Specified Index, Position, or Offset\n- CWE-1286: Syntactic Correctness\n- CWE-1287: Specified Type\n- CWE-1288: Consistency within Input\n- CWE-1289: Unsafe Equivalence\n- CWE-116: Improper Encoding or Escaping of Output\n\n\n### Additional Notes\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\n**[Maintenance]** As of 2020, this entry is used more often than preferred, and it is a source of frequent confusion. It is being actively modified for CWE 4.1 and subsequent versions.\n\n**[Maintenance]** Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document.\n\n**[Maintenance]** Input validation - whether missing or incorrect - is such an essential and widespread part of secure development that it is implicit in many different weaknesses. Traditionally, problems such as buffer overflows and XSS have been classified as input validation problems by many security professionals. However, input validation is not necessarily the only protection mechanism available for avoiding such problems, and in some cases it is not even sufficient. The CWE team has begun capturing these subtleties in chains within the Research Concepts view (CWE-1000), but more work is needed.\n\n**[Terminology]** \n\nThe \"input validation\" term is extremely common, but it is used in many different ways. In some cases its usage can obscure the real underlying weakness or otherwise hide chaining and composite relationships.\n\n\nSome people use \"input validation\" as a general term that covers many different neutralization techniques for ensuring that input is appropriate, such as filtering, canonicalization, and escaping. Others use the term in a more narrow context to simply mean \"checking if an input conforms to expectations without changing it.\" CWE uses this more narrow interpretation.\n\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2021-30860:** Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-611: Improper Restriction of XML External Entity Reference\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.\n\n### Extended Description\n\n\nXML documents optionally contain a Document Type Definition (DTD), which, among other features, enables the definition of XML entities. It is possible to define an entity by providing a substitution string in the form of a URI. The XML parser can access the contents of this URI and embed these contents back into the XML document for further processing.\n\n\nBy submitting an XML file that defines an external entity with a file:// URI, an attacker can cause the processing application to read the contents of a local file. For example, a URI such as \"file:///c:/winnt/win.ini\" designates (in Windows) the file C:\\Winnt\\win.ini, or file:///etc/passwd designates the password file in Unix-based systems. Using URIs with other schemes such as http://, the attacker can force the application to make outgoing requests to servers that the attacker cannot reach directly, which can be used to bypass firewall restrictions or hide the source of attacks such as port scanning.\n\n\nOnce the content of the URI is read, it is fed back into the application that is processing the XML. This application may echo back the data (e.g. in an error message), thereby exposing the file contents.\n\n\n### Alternative Terms\nXXE: An acronym used for the term \"XML eXternal Entities\"\n\n### Relationships\nChildOf -> CWE-610\nChildOf -> CWE-610\nPeerOf -> CWE-441\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2022-42745:** Recruiter software allows reading arbitrary files using XXE\n- **CVE-2005-1306:** A browser control can allow remote attackers to determine the existence of files via Javascript containing XML script.\n- **CVE-2012-5656:** XXE during SVG image conversion\n\n\n\n\n## CWE-134: Use of Externally-Controlled Format String\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source.\n\n### Extended Description\n\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-668\nChildOf -> CWE-668\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any programming language that support format strings.\n\n\n**[Other]** \n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n\n\n**[Research Gap]** Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.\n\n\n\n### Observed Examples\n- **CVE-2002-1825:** format string in Perl program\n- **CVE-2001-0717:** format string in bad call to syslog function\n- **CVE-2002-0573:** format string in bad call to syslog function\n\n",
    "enhanced_query": "## Vulnerability Description\nA **code injection** vulnerability exists in Pulse Connect Secure <9.1R8 that allows an attacker to crafted a URI to perform an arbitrary code execution via the admin web interface.\n\n### Vulnerability Description Key Phrases\n- **rootcause:** **improper input sanitization**\n- **weakness:** **code injection**\n- **impact:** remote code execution\n- **vector:** crafted URI\n- **attacker:** attacker\n- **product:** Pulse Connect Secure\n- **version:** <9.1R8\n- **component:** admin web interface\n\n## CVE Reference Links Content Summary\nThe provided content discusses multiple vulnerabilities in Pulse Connect Secure, including CVE-2020-8218, and provides detailed technical information about their exploitation.\n\n**CVE-2020-8218**\n\n*   **Root Cause:** Command injection vulnerability in the `downloadlicenses.cgi` file of the admin portal. Specifically, the `$authCode` variable, which is user-controlled, is directly incorporated into a system command.\n*   **Weaknesses:**\n    *   Unsanitized user input: The `authCode` variable is not properly sanitized before being used in a system call, allowing command injection.\n    *   Use of system(): The use of the `system()` function without adequate input validation opens the door to command execution.\n*   **Impact:** Remote code execution. An attacker can execute arbitrary commands on the system with the privileges of the web server.\n*   **Attack Vector:** The vulnerability can be exploited by sending a specially crafted request to `downloadlicenses.cgi` with malicious input for the `$authCode` parameter.\n*   **Required Attacker Capabilities:**\n    *   Requires admin-level authentication to access the vulnerable endpoint.\n\nThe document also discusses three other vulnerabilities:\n\n**CVE-2020-8238:**\n\n*   **Root Cause:** Reflected XSS in the `launch.cgi` endpoint. The URL parameter is directly reflected in the HTTP response without sanitization.\n*   **Weaknesses:**\n    *   Lack of input sanitization: The URL parameter is not sanitized or validated before being included in the server's response, making it vulnerable to XSS.\n    *   Conditional payload execution: The vulnerability is only triggered when a colon (:) character is present in the URL parameter, due to a check related to web bookmarks.\n*  **Impact:** Session hijacking. An attacker can steal the session cookie of an authenticated user.\n*  **Attack Vector:** Sending a specially crafted URL with a malicious payload within the `url` parameter. The malicious URL is triggered when the user clicks on it, redirecting the browser to an attacker-controlled site and sending the session cookie.\n* **Required Attacker Capabilities:** An unauthenticated attacker can trick an authenticated admin into clicking a malicious link.\n\n**CVE-2020-8256:**\n\n*   **Root Cause:** XML External Entity (XXE) injection in the admin dashboard when processing user-supplied teleconference bridge profiles.\n*   **Weaknesses:**\n    *   Lack of input sanitization: The XML templates provided by the user are not properly validated for external entities.\n    *   Vulnerable XML parser: The parser allows the inclusion of external entities, making it vulnerable to XXE attacks.\n*   **Impact:** Arbitrary file read. An attacker can read files on the remote filesystem.\n*   **Attack Vector:** Uploading a malicious XML template containing an XXE payload and then viewing the template within the admin dashboard.\n*   **Required Attacker Capabilities:** Authenticated user access to the admin dashboard.\n\n**XSS through command injection in downloadlicenses.cgi:**\n\n*   **Root Cause:** Reflected XSS in the `downloadlicenses.cgi` endpoint. The server directly outputs URL parameters, which a malicious user can control, on the page when the license code is incorrect.\n*    **Weaknesses:**\n        *   Lack of output sanitization: URL parameters are directly printed to the output without proper encoding, leading to XSS.\n*   **Impact:** Session hijacking. An attacker can steal the session cookie of an admin.\n*   **Attack Vector:** By crafting a malicious URL that includes javascript code within the `txtVLSAuthCode` parameter and tricking the admin into accessing the URL.\n*   **Required Attacker Capabilities:** An unauthenticated attacker can trick an authenticated admin into clicking a malicious link.\n\nThe document also details how the researchers extracted the source code from the appliance using a memory manipulation technique.\n\nThis content provides a good amount of detail for CVE-2020-8218, especially compared to the placeholder CVE description.\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 138 | Improper Neutralization of Special Elements | Class | Discouraged | sparse | 0.207 |\n| 2 | 1336 | Improper Neutralization of Special Elements Used in a Template Engine | Base | Allowed | sparse | 0.200 |\n| 3 | 94 | Improper Control of Generation of Code ('Code Injection') | Base | Allowed-with-Review | sparse | 0.200 |\n| 4 | 434 | Unrestricted Upload of File with Dangerous Type | Base | Allowed | sparse | 0.199 |\n| 5 | 78 | Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection') | Base | Allowed | sparse | 0.197 |\n| 6 | 96 | Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection') | Base | Allowed | dense | 0.631 |\n| 7 | 73 | External Control of File Name or Path | Base | Allowed | graph | 0.003 |\n| 8 | 20 | Improper Input Validation | Class | Discouraged | sparse | 0.185 |\n| 9 | 611 | Improper Restriction of XML External Entity Reference | Base | Allowed | sparse | 0.183 |\n| 10 | 134 | Use of Externally-Controlled Format String | Base | Allowed | sparse | 0.180 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-138: Improper Neutralization of Special Elements\n**Abstraction:** Class\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.\n\n### Extended Description\nMost languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If product does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol < (\"less than\") as meaning \"read input from a file\".\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** This CWE entry is a level-1 Class (i.e., a child of a Pillar). It might have lower-level children that would be more appropriate\n**Comments:** Examine children of this entry to see if there is a better fit\n**Reasons:**\n- Abstraction\n\n\n### Additional Notes\n**[Relationship]** This weakness can be related to interpretation conflicts or interaction errors in intermediaries (such as proxies or application firewalls) when the intermediary's model of an endpoint does not account for protocol-specific special elements.\n\n**[Relationship]** See this entry's children for different types of special elements that have been observed at one point or another. However, it can be difficult to find suitable CVE examples. In an attempt to be complete, CWE includes some types that do not have any associated observed example.\n\n**[Research Gap]** This weakness is probably under-studied for proprietary or custom formats. It is likely that these issues are fairly common in applications that use their own custom format for configuration files, logs, meta-data, messaging, etc. They would only be found by accident or with a focused effort based on an understanding of the format.\n\n\n\n### Observed Examples\n- **CVE-2001-0677:** Read arbitrary files from mail client by providing a special MIME header that is internally used to store pathnames for attachments.\n- **CVE-2000-0703:** Setuid program does not cleanse special escape sequence before sending data to a mail program, causing the mail program to process those sequences.\n- **CVE-2003-0020:** Multi-channel issue. Terminal escape sequences not filtered from log files.\n\n\n\n\n## CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product uses a template engine to insert or process externally-influenced input, but it does not neutralize or incorrectly neutralizes special elements or syntax that can be interpreted as template expressions or other code directives when processed by the engine.\n\n### Extended Description\n\n\nMany web applications use template engines that allow developers to insert externally-influenced values into free text or messages in order to generate a full web page, document, message, etc. Such engines include Twig, Jinja2, Pug, Java Server Pages, FreeMarker, Velocity, ColdFusion, Smarty, and many others - including PHP itself. Some CMS (Content Management Systems) also use templates.\n\n\nTemplate engines often have their own custom command or expression language. If an attacker can influence input into a template before it is processed, then the attacker can invoke arbitrary expressions, i.e. perform injection attacks. For example, in some template languages, an attacker could inject the expression \"{{7*7}}\" and determine if the output returns \"49\" instead. The syntax varies depending on the language.\n\n\nIn some cases, XSS-style attacks can work, which can obscure the root cause if the developer does not closely investigate the root cause of the error.\n\n\nTemplate engines can be used on the server or client, so both \"sides\" could be affected by injection. The mechanisms of attack or the affected technologies might be different, but the mistake is fundamentally the same.\n\n\n### Alternative Terms\nServer-Side Template Injection / SSTI: This term is used for injection into template engines being used by a server.\nClient-Side Template Injection / CSTI: This term is used for injection into template engines being used by a client.\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** Since expression languages are often used in templating languages, there may be some overlap with CWE-917 (Expression Language Injection). XSS (CWE-79) is also co-located with template injection.\n\n**[Maintenance]** The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified.\n\n\n\n### Observed Examples\n- **CVE-2024-34359:** Chain: Python bindings for LLM library do not use a sandboxed environment when parsing a template and constructing a prompt, allowing jinja2 Server Side Template Injection and code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2017-16783:** server-side template injection in content management server\n- **CVE-2020-9437:** authentication / identity management product has client-side template injection\n\n\n\n\n## CWE-94: Improper Control of Generation of Code ('Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.\n\n### Extended Description\n\n\nWhen a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution.\n\n\nInjection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-74\nChildOf -> CWE-74\nChildOf -> CWE-913\n\n### Mapping Guidance\n**Usage:** Allowed-with-Review\n**Rationale:** This entry is frequently misused for vulnerabilities with a technical impact of \"code execution,\" which does not by itself indicate a root cause weakness, since dozens of weaknesses can enable code execution.\n**Comments:** This weakness only applies when the product's functionality intentionally constructs all or part of a code segment. It could be that executing code could be the result of other weaknesses that do not involve the construction of code segments.\n**Reasons:**\n- Frequent Misuse\n- Frequent Misinterpretation\n\n\n\n### Observed Examples\n- **CVE-2023-29374:** Math component in an LLM framework translates user input into a Python expression that is input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-5565:** Python-based library uses an LLM prompt containing user input to dynamically generate code that is then fed as input into the Python exec() method, allowing code execution - one variant of a \"prompt injection\" attack.\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n\n\n\n\n## CWE-434: Unrestricted Upload of File with Dangerous Type\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product allows the upload or transfer of dangerous file types that are automatically processed within its environment.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nUnrestricted File Upload: Used in vulnerability databases and elsewhere, but it is insufficiently precise. The phrase could be interpreted as the lack of restrictions on the size or number of uploaded files, which is a resource consumption issue.\n\n### Relationships\nChildOf -> CWE-669\nChildOf -> CWE-669\nPeerOf -> CWE-351\nPeerOf -> CWE-436\nPeerOf -> CWE-430\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \n\nThis can have a chaining relationship with incomplete denylist / permissive allowlist errors when the product tries, but fails, to properly limit which types of files are allowed (CWE-183, CWE-184).\n\n\nThis can also overlap multiple interpretation errors for intermediaries, e.g. anti-virus products that do not remove or quarantine attachments with certain file extensions that can be processed by client systems.\n\n\n\n\n### Observed Examples\n- **CVE-2023-5227:** PHP-based FAQ management app does not check the MIME type for uploaded images\n- **CVE-2001-0901:** Web-based mail product stores \".shtml\" attachments that could contain SSI\n- **CVE-2002-1841:** PHP upload does not restrict file types\n\n\n\n\n## CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.\n\n### Extended Description\n\n\nThis weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.\n\n\nThere are at least two subtypes of OS command injection:\n\n\n  - The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(\"nslookup [HOSTNAME]\") to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.\n\n  - The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use \"exec([COMMAND])\" to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.\n\nFrom a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.\n\n### Alternative Terms\nShell injection\nShell metacharacters\nOS Command Injection\n\n### Relationships\nChildOf -> CWE-77\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\nCanAlsoBe -> CWE-88\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Terminology]** The \"OS command injection\" phrase carries different meanings to different people. For some people, it only refers to cases in which the attacker injects command separators into arguments for an application-controlled program that is being invoked. For some people, it refers to any type of attack that can allow the attacker to execute OS commands of their own choosing. This usage could include untrusted search path weaknesses (CWE-426) that cause the application to find and execute an attacker-controlled program. Further complicating the issue is the case when argument injection (CWE-88) allows alternate command-line switches or options to be inserted into the command line, such as an \"-exec\" switch whose purpose may be to execute the subsequent argument as a command (this -exec switch exists in the UNIX \"find\" command, for example). In this latter case, however, CWE-88 could be regarded as the primary weakness in a chain with CWE-78.\n\n**[Research Gap]** More investigation is needed into the distinction between the OS command injection variants, including the role with argument injection (CWE-88). Equivalent distinctions may exist in other injection-related problems such as SQL injection.\n\n\n\n### Observed Examples\n- **CVE-2020-10987:** OS command injection in Wi-Fi router, as exploited in the wild per CISA KEV.\n- **CVE-2020-10221:** Template functionality in network configuration management tool allows OS command injection, as exploited in the wild per CISA KEV.\n- **CVE-2020-9054:** Chain: improper input validation (CWE-20) in username parameter, leading to OS command injection (CWE-78), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** \"HTML injection\" (see CWE-79: XSS) could be thought of as an example of this, but the code is injected and executed on the client side, not the server side. Server-Side Includes (SSI) are an example of direct static code injection.\n\n\n\n### Observed Examples\n- **CVE-2002-0495:** Perl code directly injected into CGI library file from parameters to another CGI program.\n- **CVE-2005-1876:** Direct PHP code injection into supporting template file.\n- **CVE-2005-1894:** Direct code injection into PHP script that can be accessed by attacker.\n\n\n\n\n## CWE-73: External Control of File Name or Path\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product allows user input to control or influence paths or file names that are used in filesystem operations.\n\n### Extended Description\n\n\nThis could allow an attacker to access or modify system files or other files that are critical to the application.\n\n\nPath manipulation errors occur when the following two conditions are met:\n\n```\n\t\t1. An attacker can specify a path used in an operation on the filesystem.\n\t\t2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.\n```\nFor example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-642\nChildOf -> CWE-610\nChildOf -> CWE-20\nCanPrecede -> CWE-22\nCanPrecede -> CWE-41\nCanPrecede -> CWE-98\nCanPrecede -> CWE-434\nCanPrecede -> CWE-59\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** CWE-114 is a Class, but it is listed a child of CWE-73 in view 1000. This suggests some abstraction problems that should be resolved in future versions.\n\n**[Relationship]** \n\nThe external control of filenames can be the primary link in chains with other file-related weaknesses, as seen in the CanPrecede relationships. This is because software systems use files for many different purposes: to execute programs, load code libraries, to store application data, to store configuration settings, record temporary data, act as signals or semaphores to other processes, etc.\n\n\nHowever, those weaknesses do not always require external control. For example, link-following weaknesses (CWE-59) often involve pathnames that are not controllable by the attacker at all.\n\n\nThe external control can be resultant from other issues. For example, in PHP applications, the register_globals setting can allow an attacker to modify variables that the programmer thought were immutable, enabling file inclusion (CWE-98) and path traversal (CWE-22). Operating with excessive privileges (CWE-250) might allow an attacker to specify an input filename that is not directly readable by the attacker, but is accessible to the privileged program. A buffer overflow (CWE-119) might give an attacker control over nearby memory locations that are related to pathnames, but were not directly modifiable by the attacker.\n\n\n\n\n### Observed Examples\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2008-5748:** Chain: external control of values for user's desired language and theme enables path traversal.\n- **CVE-2008-5764:** Chain: external control of user's target language enables remote file inclusion.\n\n\n\n\n## CWE-20: Improper Input Validation\n**Abstraction:** Class\n**Status:** Stable\n\n### Description\nThe product receives input or data, but it does\n        not validate or incorrectly validates that the input has the\n        properties that are required to process the data safely and\n        correctly.\n\n### Extended Description\n\n\nInput validation is a frequently-used technique for checking potentially dangerous inputs in order to ensure that the inputs are safe for processing within the code, or when communicating with other components. When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.\n\n\nInput validation is not the only technique for processing input, however. Other techniques attempt to transform potentially-dangerous input into something safe, such as filtering (CWE-790) - which attempts to remove dangerous inputs - or encoding/escaping (CWE-116), which attempts to ensure that the input is not misinterpreted when it is included in output to another component. Other techniques exist as well (see CWE-138 for more examples.)\n\n\nInput validation can be applied to:\n\n\n  - raw data - strings, numbers, parameters, file contents, etc.\n\n  - metadata - information about the raw data, such as headers or size\n\nData can be simple or structured. Structured data can be composed of many nested layers, composed of combinations of metadata and raw data, with other simple or structured data.\n\nMany properties of raw data or metadata may need to be validated upon entry into the code, such as:\n\n\n  - specified quantities such as size, length, frequency, price, rate, number of operations, time, etc.\n\n  - implied or derived quantities, such as the actual size of a file instead of a specified size\n\n  - indexes, offsets, or positions into more complex data structures\n\n  - symbolic keys or other elements into hash tables, associative arrays, etc.\n\n  - well-formedness, i.e. syntactic correctness - compliance with expected syntax \n\n  - lexical token correctness - compliance with rules for what is treated as a token\n\n  - specified or derived type - the actual type of the input (or what the input appears to be)\n\n  - consistency - between individual data elements, between raw data and metadata, between references, etc.\n\n  - conformance to domain-specific rules, e.g. business logic \n\n  - equivalence - ensuring that equivalent inputs are treated the same\n\n  - authenticity, ownership, or other attestations about the input, e.g. a cryptographic signature to prove the source of the data\n\nImplied or derived properties of data must often be calculated or inferred by the code itself. Errors in deriving properties may be considered a contributing factor to improper input validation. \n\nNote that \"input validation\" has very different meanings to different people, or within different classification schemes. Caution must be used when referencing this CWE entry or mapping to it. For example, some weaknesses might involve inadvertently giving control to an attacker over an input when they should not be able to provide an input at all, but sometimes this is referred to as input validation.\n\n\nFinally, it is important to emphasize that the distinctions between input validation and output escaping are often blurred, and developers must be careful to understand the difference, including how input validation is not always sufficient to prevent vulnerabilities, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a person's last name is inserted into a query. The name \"O'Reilly\" would likely pass the validation step since it is a common last name in the English language. However, this valid name cannot be directly inserted into the database because it contains the \"'\" apostrophe character, which would need to be escaped or otherwise transformed. In this case, removing the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\nPeerOf -> CWE-345\nCanPrecede -> CWE-22\nCanPrecede -> CWE-41\nCanPrecede -> CWE-74\nCanPrecede -> CWE-119\nCanPrecede -> CWE-770\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-20 is commonly misused in low-information vulnerability reports when lower-level CWEs could be used instead, or when more details about the vulnerability are available [REF-1287]. It is not useful for trend analysis. It is also a level-1 Class (i.e., a child of a Pillar).\n**Comments:** Consider lower-level children such as Improper Use of Validation Framework (CWE-1173) or improper validation involving specific types or properties of input such as Specified Quantity (CWE-1284); Specified Index, Position, or Offset (CWE-1285); Syntactic Correctness (CWE-1286); Specified Type (CWE-1287); Consistency within Input (CWE-1288); or Unsafe Equivalence (CWE-1289).\n**Reasons:**\n- Frequent Misuse\n**Suggested Alternatives:**\n- CWE-1284: Specified Quantity\n- CWE-1285: Specified Index, Position, or Offset\n- CWE-1286: Syntactic Correctness\n- CWE-1287: Specified Type\n- CWE-1288: Consistency within Input\n- CWE-1289: Unsafe Equivalence\n- CWE-116: Improper Encoding or Escaping of Output\n\n\n### Additional Notes\n**[Relationship]** \n\nCWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks.\n\n\n**[Maintenance]** As of 2020, this entry is used more often than preferred, and it is a source of frequent confusion. It is being actively modified for CWE 4.1 and subsequent versions.\n\n**[Maintenance]** Concepts such as validation, data transformation, and neutralization are being refined, so relationships between CWE-20 and other entries such as CWE-707 may change in future versions, along with an update to the Vulnerability Theory document.\n\n**[Maintenance]** Input validation - whether missing or incorrect - is such an essential and widespread part of secure development that it is implicit in many different weaknesses. Traditionally, problems such as buffer overflows and XSS have been classified as input validation problems by many security professionals. However, input validation is not necessarily the only protection mechanism available for avoiding such problems, and in some cases it is not even sufficient. The CWE team has begun capturing these subtleties in chains within the Research Concepts view (CWE-1000), but more work is needed.\n\n**[Terminology]** \n\nThe \"input validation\" term is extremely common, but it is used in many different ways. In some cases its usage can obscure the real underlying weakness or otherwise hide chaining and composite relationships.\n\n\nSome people use \"input validation\" as a general term that covers many different neutralization techniques for ensuring that input is appropriate, such as filtering, canonicalization, and escaping. Others use the term in a more narrow context to simply mean \"checking if an input conforms to expectations without changing it.\" CWE uses this more narrow interpretation.\n\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n- **CVE-2021-30860:** Chain: improper input validation (CWE-20) leads to integer overflow (CWE-190) in mobile OS, as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-611: Improper Restriction of XML External Entity Reference\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.\n\n### Extended Description\n\n\nXML documents optionally contain a Document Type Definition (DTD), which, among other features, enables the definition of XML entities. It is possible to define an entity by providing a substitution string in the form of a URI. The XML parser can access the contents of this URI and embed these contents back into the XML document for further processing.\n\n\nBy submitting an XML file that defines an external entity with a file:// URI, an attacker can cause the processing application to read the contents of a local file. For example, a URI such as \"file:///c:/winnt/win.ini\" designates (in Windows) the file C:\\Winnt\\win.ini, or file:///etc/passwd designates the password file in Unix-based systems. Using URIs with other schemes such as http://, the attacker can force the application to make outgoing requests to servers that the attacker cannot reach directly, which can be used to bypass firewall restrictions or hide the source of attacks such as port scanning.\n\n\nOnce the content of the URI is read, it is fed back into the application that is processing the XML. This application may echo back the data (e.g. in an error message), thereby exposing the file contents.\n\n\n### Alternative Terms\nXXE: An acronym used for the term \"XML eXternal Entities\"\n\n### Relationships\nChildOf -> CWE-610\nChildOf -> CWE-610\nPeerOf -> CWE-441\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Relationship]** CWE-918 (SSRF) and CWE-611 (XXE) are closely related, because they both involve web-related technologies and can launch outbound requests to unexpected destinations. However, XXE can be performed client-side, or in other contexts in which the software is not acting directly as a server, so the \"Server\" portion of the SSRF acronym does not necessarily apply.\n\n\n\n### Observed Examples\n- **CVE-2022-42745:** Recruiter software allows reading arbitrary files using XXE\n- **CVE-2005-1306:** A browser control can allow remote attackers to determine the existence of files via Javascript containing XML script.\n- **CVE-2012-5656:** XXE during SVG image conversion\n\n\n\n\n## CWE-134: Use of Externally-Controlled Format String\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product uses a function that accepts a format string as an argument, but the format string originates from an external source.\n\n### Extended Description\n\n\nWhen an attacker can modify an externally-controlled format string, this can lead to buffer overflows, denial of service, or data representation problems.\n\n\nIt should be noted that in some circumstances, such as internationalization, the set of format strings is externally controlled by design. If the source of these format strings is trusted (e.g. only contained in library files that are only modifiable by the system administrator), then the external control might not itself pose a vulnerability.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-668\nChildOf -> CWE-668\nCanPrecede -> CWE-123\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Applicable Platform]** \n\nThis weakness is possible in any programming language that support format strings.\n\n\n**[Other]** \n\nWhile Format String vulnerabilities typically fall under the Buffer Overflow category, technically they are not overflowed buffers. The Format String vulnerability is fairly new (circa 1999) and stems from the fact that there is no realistic way for a function that takes a variable number of arguments to determine just how many arguments were passed in. The most common functions that take a variable number of arguments, including C-runtime functions, are the printf() family of calls. The Format String problem appears in a number of ways. A *printf() call without a format specifier is dangerous and can be exploited. For example, printf(input); is exploitable, while printf(y, input); is not exploitable in that context. The result of the first call, used incorrectly, allows for an attacker to be able to peek at stack memory since the input string will be used as the format specifier. The attacker can stuff the input string with format specifiers and begin reading stack values, since the remaining parameters will be pulled from the stack. Worst case, this improper use may give away enough control to allow an arbitrary value (or values in the case of an exploit program) to be written into the memory of the running program.\n\n\nFrequently targeted entities are file names, process names, identifiers.\n\n\nFormat string problems are a classic C/C++ issue that are now rare due to the ease of discovery. One main reason format string vulnerabilities can be exploited is due to the %n operator. The %n operator will write the number of characters, which have been printed by the format string therefore far, to the memory pointed to by its argument. Through skilled creation of a format string, a malicious user may use values on the stack to create a write-what-where condition. Once this is achieved, they can execute arbitrary code. Other operators can be used as well; for example, a %9999s operator could also trigger a buffer overflow, or when used in file-formatting functions like fprintf, it can generate a much larger output than intended.\n\n\n**[Research Gap]** Format string issues are under-studied for languages other than C. Memory or disk consumption, control flow or variable alteration, and data corruption may result from format string exploitation in applications written in other languages such as Perl, PHP, Python, etc.\n\n\n\n### Observed Examples\n- **CVE-2002-1825:** format string in Perl program\n- **CVE-2001-0717:** format string in bad call to syslog function\n- **CVE-2002-0573:** format string in bad call to syslog function\n\n Consider specifically these CWEs: CWE-1336 CWE-88 CWE-73 CWE-134 CWE-138 CWE-74 CWE-116 CWE-22 CWE-184",
    "cwe_mentions": [
      "CWE-1336",
      "CWE-88",
      "CWE-73",
      "CWE-134",
      "CWE-138",
      "CWE-74",
      "CWE-116",
      "CWE-22",
      "CWE-184"
    ],
    "search_time": 2.835963487625122
  },
  "timestamp": "2025-04-02 12:33:31",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "78",
      "name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "434",
      "name": "Unrestricted Upload of File with Dangerous Type",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "98",
      "name": "Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')",
      "type": "variant",
      "score": 4.39872,
      "relationship_count": 0
    },
    {
      "cwe_id": "94",
      "name": "Improper Control of Generation of Code ('Code Injection')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "79",
      "name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "770",
      "name": "Allocation of Resources Without Limits or Throttling",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "190",
      "name": "Integer Overflow or Wraparound",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "123",
      "name": "Write-what-where Condition",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "917",
      "name": "Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    }
  ]
}