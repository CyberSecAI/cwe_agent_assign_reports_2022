{
  "retriever": "graph",
  "query": "## Vulnerability Description\nGo before 1.15.13 and 1.16.x before 1.16.5 has functions for DNS lookups that do not validate replies from DNS servers, and thus a return value may contain an **unsafe injection** (e.g., XSS) that does not conform to the RFC1035 format.\n\n### Vulnerability Description Key Phrases\n- **weakness:** **unsafe injection**\n- **impact:** cross-site scripting\n- **product:** Go\n- **version:** before 1.15.13 and 1.16.x before 1.16.5\n- **component:** DNS lookup functions\n\n## CVE Reference Links Content Summary\n```json\n[\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The `net.Lookup{Addr,CNAME,Host}` functions, when using the pure Go resolver, don't filter returned host name string types, allowing invalid names to be returned to the caller. These names, if used in an unsanitized context, could lead to injection of unexpected content.\",\n    \"weaknesses\": [\n      \"Lack of input sanitization\",\n      \"Improper validation of hostnames\"\n    ],\n    \"impact\": \"Injection of unexpected content due to using invalid hostnames in unsanitized contexts which can lead to information disclosure, data modification, or denial of service.\",\n    \"attack_vectors\": [\n      \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker can exploit this vulnerability by controlling the DNS responses received by a vulnerable application, which may be achieved by controlling the DNS server or via a man-in-the-middle attack.\",\n    \"additional_information\": \"The vulnerability is present in Go versions before 1.15.12 and 1.16.x before 1.16.5. The vulnerability is triggered when the pure Go resolver is used. The cgo resolver may impose its own filtering, but this cannot be relied upon. The `isDomainName` function, which applies RFC 1035 LDH rules, can be used to validate returned names.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"Go versions prior to 1.15.13 and 1.16.x prior to 1.16.5 are susceptible to a vulnerability which, when successfully exploited, could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS). This is due to the net.Lookup functions returning invalid hostnames.\",\n      \"weaknesses\": [\n        \"Improper input validation\"\n     ],\n     \"impact\": \"Disclosure of sensitive information, data modification, or denial of service (DoS).\",\n     \"attack_vectors\": [\n      \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker may be able to manipulate DNS results returned to a vulnerable system.\",\n      \"additional_information\": \"NetApp products are affected when they incorporate vulnerable versions of Golang. The provided link points to a Google Groups discussion related to Go 1.16.5 and 1.15.13 releases, which include security fixes.\"\n  },\n  {\n     \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The `net` package in Go does not properly validate hostnames returned by DNS lookups, allowing arbitrary values which do not follow RFC 1035 rules for domain names to be returned, leading to potential injection issues if used without sanitization.\",\n    \"weaknesses\": [\n      \"Improper input validation\",\n      \"Lack of sanitization for DNS query responses\"\n    ],\n    \"impact\": \"The vulnerability can lead to injection of unexpected content if arbitrary values from DNS responses are used without proper sanitization, potentially resulting in data modification, information disclosure, or a denial of service.\",\n    \"attack_vectors\": [\n      \"Network\"\n    ],\n     \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can inject arbitrary data into the application using this vulnerability.\",\n     \"additional_information\": \"This is issue #46241 in the golang/go repository, and it is also identified as CVE-2021-33195. The affected functions include `LookupCNAME`, `LookupSRV`, `LookupMX`, `LookupNS`, and `LookupAddr`. A possible fix involves checking returned names with the existing `isDomainName` function to ensure they conform to RFC 1035 LDH rules.\"\n  },\n    {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability is caused by the use of the `net.Lookup{Addr,CNAME,Host}` functions with the pure Go resolver, which does not validate or filter returned host name strings, leading to the possibility of injecting unexpected content if not sanitized.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n      \"Lack of output sanitization\"\n    ],\n    \"impact\": \"The impact is the injection of unexpected content. This could lead to a variety of consequences, including information disclosure, data modification, or denial of service, depending on the specific context where the unsanitized data is used.\",\n     \"attack_vectors\": [\n       \"Network\"\n      ],\n    \"attacker_capabilities\": \"An attacker would need to control DNS responses to inject arbitrary, invalid hostnames into the application that uses a vulnerable version of Go.\",\n     \"additional_information\": \"The vulnerability is assigned CVE-2021-33195. The `net` package in Go, specifically when using the pure Go resolver, does not filter or validate host name string types. This can be mitigated by checking returned names with the existing `isDomainName` function.\"\n  },\n    {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability arises from the fact that the `net.Lookup{Addr,CNAME,Host}` functions don't filter returned host name string types when using the pure Go resolver. This allows for invalid names to be returned, which, if used in unsanitized contexts, can lead to injection issues.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n     \"Lack of Output Sanitization\"\n    ],\n    \"impact\": \"The impact is potential injection of unexpected content. This could lead to vulnerabilities such as Cross-Site Scripting (XSS), data modification, or denial of service, depending on how the invalid hostname string is used.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can exploit this vulnerability by injecting arbitrary, invalid hostnames.\",\n    \"additional_information\": \"The affected functions are `net.Lookup{Addr, CNAME, Host}` when using the pure Go resolver. This issue is tracked as CVE-2021-33195. The recommended approach is to check the returned names using the `isDomainName` function, which applies RFC 1035 LDH rules.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability stems from the way the `net.Lookup{Addr,CNAME,Host}` functions handle DNS responses when using the pure Go resolver. They do not validate or filter the returned host name strings, allowing for invalid names that can cause injection vulnerabilities.\",\n     \"weaknesses\": [\n        \"Improper Input Validation\",\n       \"Lack of Output Sanitization\"\n      ],\n    \"impact\": \"The lack of validation allows for the injection of unexpected content, possibly leading to data modification, information disclosure, or denial of service (DoS) depending on how the application uses these names.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker could exploit this by controlling the DNS server or performing a man-in-the-middle attack to provide responses containing invalid host names.\",\n     \"additional_information\": \"The CVE ID for this vulnerability is CVE-2021-33195. The suggested remediation is to implement validation using the `isDomainName` function, which applies RFC 1035 LDH rules and filter out invalid names, or apply other sanitization techniques.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The net.Lookup functions return arbitrary values from DNS which do not follow the rules for domain names according to RFC 1035.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n      \"Lack of Output Sanitization\"\n    ],\n    \"impact\": \"When the returned names are used without sanitization, for instance in HTML, they can allow injection of unexpected content.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n     \"attacker_capabilities\": \"An attacker with the ability to influence DNS responses can inject arbitrary content.\",\n     \"additional_information\": \"This issue is identified as CVE-2021-33195, and it's noted that `LookupTXT` may still return arbitrary values that may require sanitization.\"\n  },\n    {\n     \"related_to_CVE\": \"CVE-2021-33195\",\n      \"root_cause\": \"The `net.Lookup{Addr,CNAME,Host}` functions do not properly filter returned host names when using the pure Go resolver. This can allow for invalid names to be returned to the caller, which can lead to injection vulnerabilities if used in unsanitized contexts.\",\n      \"weaknesses\": [\n        \"Improper Input Validation\",\n       \"Lack of Input Sanitization\"\n     ],\n      \"impact\": \"The use of invalid host names in an unsanitized context can lead to injection of unexpected content, potentially resulting in information disclosure, data modification, or denial of service.\",\n      \"attack_vectors\": [\n      \"Network\"\n      ],\n      \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can exploit this vulnerability.\",\n    \"additional_information\":\"This vulnerability is identified as CVE-2021-33195. The issue occurs because returned names are not checked against the RFC 1035 LDH rules. The cgo resolver might do some filtering, but this is not consistent. The fix should involve checking the returned names using the `isDomainName` function.\"\n  }\n]\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 1286 | Improper Validation of Syntactic Correctness of Input | Base | Allowed | sparse | 0.349 |\n| 2 | 917 | Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection') | Base | Allowed | sparse | 0.235 |\n| 3 | 113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | sparse | 0.226 |\n| 4 | 95 | Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') | Variant | Allowed | sparse | 0.225 |\n| 5 | 295 | Improper Certificate Validation | Base | Allowed | sparse | 0.222 |\n| 6 | 350 | Reliance on Reverse DNS Resolution for a Security-Critical Action | Variant | Allowed | dense | 0.542 |\n| 7 | 322 | Key Exchange without Entity Authentication | Base | Allowed | graph | 0.002 |\n| 8 | 74 | Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection') | Class | Discouraged | sparse | 0.221 |\n| 9 | 502 | Deserialization of Untrusted Data | Base | Allowed | sparse | 0.220 |\n| 10 | 22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | Base | Allowed | sparse | 0.220 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-1286: Improper Validation of Syntactic Correctness of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be well-formed - i.e., to comply with a certain syntax - but it does not validate or incorrectly validates that the input complies with the syntax.\n\n### Extended Description\n\n\nOften, complex inputs are expected to follow a particular syntax, which is either assumed by the input itself, or declared within metadata such as headers. The syntax could be for data exchange formats, markup languages, or even programming languages. When untrusted input is not properly validated for the expected syntax, attackers could cause parsing failures, trigger unexpected errors, or expose latent vulnerabilities that might not be directly exploitable if the input had conformed to the syntax.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2016-4029:** Chain: incorrect validation of intended decimal-based IP address format (CWE-1286) enables parsing of octal or hexadecimal formats (CWE-1389), allowing bypass of an SSRF protection mechanism (CWE-918).\n- **CVE-2007-5893:** HTTP request with missing protocol version number leads to crash\n\n\n\n\n## CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product constructs all or part of an expression language (EL) statement in a framework such as a Java Server Page (JSP) using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended EL statement before it is executed.\n\n### Extended Description\nFrameworks such as Java Server Page (JSP) allow a developer to insert executable expressions within otherwise-static content. When the developer is not aware of the executable nature of these expressions and/or does not disable them, then if an attacker can inject expressions, this could lead to code execution or other unexpected behaviors.\n\n### Alternative Terms\nEL Injection\n\n### Relationships\nChildOf -> CWE-77\nPeerOf -> CWE-1336\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified.\n\n**[Relationship]** In certain versions of Spring 3.0.5 and earlier, there was a vulnerability (CVE-2011-2730) in which Expression Language tags would be evaluated twice, which effectively exposed any application to EL injection. However, even for later versions, this weakness is still possible depending on configuration.\n\n\n\n### Observed Examples\n- **CVE-2021-44228:** Product does not neutralize ${xyz} style expressions, allowing remote code execution. (log4shell vulnerability in log4j)\n\n\n\n\n## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.\n\n### Extended Description\n\n\n HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. \n\n\nWhen an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as \"splitting\" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \\r, and LF is line feed, also given by %0a or \\n.\n\n\nIn addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \\t) and SP (space, also given as + sign or %20).\n\n\nThese types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second \"split\" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.\n\n\nHTTP response splitting weaknesses may be present when:\n\n\n  1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\n  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.\n\n\n\n### Alternative Terms\nHTTP Request Splitting\nHTTP Response Splitting\n\n### Relationships\nChildOf -> CWE-93\nCanPrecede -> CWE-79\nChildOf -> CWE-20\nChildOf -> CWE-436\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning\n- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs\n- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request\n\n\n\n\n## CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. \"eval\").\n\n### Extended Description\nThis may allow an attacker to execute arbitrary code, or at least modify what code can be executed.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Factors: special character errors can play a role in increasing the variety of code that can be injected, although some vulnerabilities do not require special characters at all, e.g. when a single function without arguments can be referenced and a terminator character is not necessary.\n\n\n\n### Observed Examples\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n- **CVE-2022-2054:** Python compiler uses eval() to execute malicious strings as Python code.\n- **CVE-2021-22204:** Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-295: Improper Certificate Validation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not validate, or incorrectly validates, a certificate.\n\n### Extended Description\nWhen a certificate is invalid or malicious, it might allow an attacker to spoof a trusted entity by interfering in the communication path between the host and client. The product might connect to a malicious host while believing it is a trusted host, or the product might be deceived into accepting spoofed data that appears to originate from a trusted host.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-287\nChildOf -> CWE-287\nPeerOf -> CWE-322\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2019-12496:** A Go framework for robotics, drones, and IoT devices skips verification of root CA certificates by default.\n- **CVE-2014-1266:** chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).\n- **CVE-2021-22909:** Chain: router's firmware update procedure uses curl with \"-k\" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).\n\n\n\n\n## CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product performs reverse DNS resolution on an IP address to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname.\n\n### Extended Description\n\n\nSince DNS names can be easily spoofed or misreported, and it may be difficult for the product to detect if a trusted DNS server has been compromised, DNS names do not constitute a valid authentication mechanism.\n\n\nWhen the product performs a reverse DNS resolution for an IP address, if an attacker controls the DNS server for that IP address, then the attacker can cause the server to return an arbitrary hostname. As a result, the attacker may be able to bypass authentication, cause the wrong hostname to be recorded in log files to hide activities, or perform other attacks.\n\n\nAttackers can spoof DNS names by either (1) compromising a DNS server and modifying its records (sometimes called DNS cache poisoning), or (2) having legitimate control over a DNS server associated with their IP address.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-290\nChildOf -> CWE-807\nCanPrecede -> CWE-923\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** CWE-350, CWE-247, and CWE-292 were merged into CWE-350 in CWE 2.5. CWE-247 was originally derived from Seven Pernicious Kingdoms, CWE-350 from PLOVER, and CWE-292 from CLASP. All taxonomies focused closely on the use of reverse DNS for authentication of incoming requests.\n\n\n\n### Observed Examples\n- **CVE-2001-1488:** Does not do double-reverse lookup to prevent DNS spoofing.\n- **CVE-2001-1500:** Does not verify reverse-resolved hostnames in DNS.\n- **CVE-2000-1221:** Authentication bypass using spoofed reverse-resolved DNS hostnames.\n\n\n\n\n## CWE-322: Key Exchange without Entity Authentication\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product performs a key exchange with an actor without verifying the identity of that actor.\n\n### Extended Description\nPerforming a key exchange will preserve the integrity of the information sent between two entities, but this will not guarantee that the entities are who they claim they are. This may enable an attacker to impersonate an actor by modifying traffic between the two entities. Typically, this involves a victim client that contacts a malicious server that is impersonating a trusted server. If the client skips authentication or ignores an authentication failure, the malicious server may request authentication information from the user. The malicious server can then use this authentication information to log in to the trusted server using the victim's credentials, sniff traffic between the victim and trusted server, etc.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-306\nCanPrecede -> CWE-923\nPeerOf -> CWE-295\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n\n\n\n## CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.\n\n### Extended Description\nSoftware or other automated logic has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for user-controlled input that leads to injection problems. Injection problems encompass a wide variety of issues -- all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features that classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-74 is high-level and often misused when lower-level weaknesses are more appropriate.\n**Comments:** Examine the children and descendants of this entry to find a more precise mapping.\n**Reasons:**\n- Frequent Misuse\n- Abstraction\n\n\n### Additional Notes\n**[Theoretical]** Many people treat injection only as an input validation problem (CWE-20) because many people do not distinguish between the consequence/attack (injection) and the protection mechanism that prevents the attack from succeeding. However, input validation is only one potential protection mechanism (output encoding is another), and there is a chaining relationship between improper input validation and the improper enforcement of the structure of messages to other components. Other issues not directly related to input validation, such as race conditions, could similarly impact message structure.\n\n\n\n### Observed Examples\n- **CVE-2024-5184:** API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.\n- **CVE-2022-36069:** Python-based dependency management tool avoids OS command injection when generating Git commands but allows injection of optional arguments with input beginning with a dash (CWE-88), potentially allowing for code execution.\n- **CVE-1999-0067:** Canonical example of OS command injection. CGI program does not neutralize \"|\" metacharacter when invoking a phonebook program.\n\n\n\n\n## CWE-502: Deserialization of Untrusted Data\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product deserializes untrusted data without sufficiently ensuring that the resulting data will be valid.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMarshaling, Unmarshaling: Marshaling and unmarshaling are effectively synonyms for serialization and deserialization, respectively.\nPickling, Unpickling: In Python, the \"pickle\" functionality is used to perform serialization and deserialization.\nPHP Object Injection: Some PHP application researchers use this term when attacking unsafe use of the unserialize() function; but it is also used for CWE-915.\n\n### Relationships\nChildOf -> CWE-913\nChildOf -> CWE-913\nPeerOf -> CWE-915\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** The relationships between CWE-502 and CWE-915 need further exploration. CWE-915 is more narrowly scoped to object modification, and is not necessarily used for deserialization.\n\n\n\n### Observed Examples\n- **CVE-2019-12799:** chain: bypass of untrusted deserialization issue (CWE-502) by using an assumed-trusted class (CWE-183)\n- **CVE-2015-8103:** Deserialization issue in commonly-used Java library allows remote execution.\n- **CVE-2015-4852:** Deserialization issue in commonly-used Java library allows remote execution.\n\n\n\n\n## CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.\n\n### Extended Description\n\n\nMany file operations are intended to take place within a restricted directory. By using special elements such as \"..\" and \"/\" separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the \"../\" sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as \"/usr/local/bin\" to access unexpected files. This is referred to as absolute path traversal.\n\n\n### Alternative Terms\nDirectory traversal\nPath traversal: \"Path traversal\" is preferred over \"directory traversal,\" but both terms are attack-focused.\n\n### Relationships\nChildOf -> CWE-706\nChildOf -> CWE-706\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to apply to a wider range of files. For example, the product may add \".txt\" to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.\n\n**[Relationship]** Pathname equivalence can be regarded as a type of canonicalization error.\n\n**[Relationship]** Some pathname equivalence issues are not directly related to directory traversal, rather are used to bypass security-relevant checks for whether a file/directory can be accessed by the attacker (e.g. a trailing \"/\" on a filename could bypass access rules that don't expect a trailing /, causing a server to provide the file when it normally would not).\n\n**[Terminology]** \n\nLike other weaknesses, terminology is often based on the types of manipulations used, instead of the underlying weaknesses. Some people use \"directory traversal\" only to refer to the injection of \"..\" and equivalent sequences whose specific meaning is to traverse directories.\n\n\nOther variants like \"absolute pathname\" and \"drive letter\" have the *effect* of directory traversal, but some people may not call it such, since it doesn't involve \"..\" or equivalent.\n\n\n**[Research Gap]** Many variants of path traversal attacks are probably under-studied with respect to root cause. CWE-790 and CWE-182 begin to cover part of this gap.\n\n**[Research Gap]** \n\nIncomplete diagnosis or reporting of vulnerabilities can make it difficult to know which variant is affected. For example, a researcher might say that \"..\\\" is vulnerable, but not test \"../\" which may also be vulnerable.\n\n\nAny combination of directory separators (\"/\", \"\\\", etc.) and numbers of \".\" (e.g. \"....\") can produce unique variants; for example, the \"//../\" variant is not listed (CVE-2004-0325). See this entry's children and lower-level descendants.\n\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n\n Consider specifically these CWEs: CWE-113 CWE-41 CWE-1289 CWE-116 CWE-74 CWE-917 CWE-22 CWE-295 CWE-23 CWE-184",
  "keyphrases": {
    "original_query": "## Vulnerability Description\nGo before 1.15.13 and 1.16.x before 1.16.5 has functions for DNS lookups that do not validate replies from DNS servers, and thus a return value may contain an **unsafe injection** (e.g., XSS) that does not conform to the RFC1035 format.\n\n### Vulnerability Description Key Phrases\n- **weakness:** **unsafe injection**\n- **impact:** cross-site scripting\n- **product:** Go\n- **version:** before 1.15.13 and 1.16.x before 1.16.5\n- **component:** DNS lookup functions\n\n## CVE Reference Links Content Summary\n```json\n[\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The `net.Lookup{Addr,CNAME,Host}` functions, when using the pure Go resolver, don't filter returned host name string types, allowing invalid names to be returned to the caller. These names, if used in an unsanitized context, could lead to injection of unexpected content.\",\n    \"weaknesses\": [\n      \"Lack of input sanitization\",\n      \"Improper validation of hostnames\"\n    ],\n    \"impact\": \"Injection of unexpected content due to using invalid hostnames in unsanitized contexts which can lead to information disclosure, data modification, or denial of service.\",\n    \"attack_vectors\": [\n      \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker can exploit this vulnerability by controlling the DNS responses received by a vulnerable application, which may be achieved by controlling the DNS server or via a man-in-the-middle attack.\",\n    \"additional_information\": \"The vulnerability is present in Go versions before 1.15.12 and 1.16.x before 1.16.5. The vulnerability is triggered when the pure Go resolver is used. The cgo resolver may impose its own filtering, but this cannot be relied upon. The `isDomainName` function, which applies RFC 1035 LDH rules, can be used to validate returned names.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"Go versions prior to 1.15.13 and 1.16.x prior to 1.16.5 are susceptible to a vulnerability which, when successfully exploited, could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS). This is due to the net.Lookup functions returning invalid hostnames.\",\n      \"weaknesses\": [\n        \"Improper input validation\"\n     ],\n     \"impact\": \"Disclosure of sensitive information, data modification, or denial of service (DoS).\",\n     \"attack_vectors\": [\n      \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker may be able to manipulate DNS results returned to a vulnerable system.\",\n      \"additional_information\": \"NetApp products are affected when they incorporate vulnerable versions of Golang. The provided link points to a Google Groups discussion related to Go 1.16.5 and 1.15.13 releases, which include security fixes.\"\n  },\n  {\n     \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The `net` package in Go does not properly validate hostnames returned by DNS lookups, allowing arbitrary values which do not follow RFC 1035 rules for domain names to be returned, leading to potential injection issues if used without sanitization.\",\n    \"weaknesses\": [\n      \"Improper input validation\",\n      \"Lack of sanitization for DNS query responses\"\n    ],\n    \"impact\": \"The vulnerability can lead to injection of unexpected content if arbitrary values from DNS responses are used without proper sanitization, potentially resulting in data modification, information disclosure, or a denial of service.\",\n    \"attack_vectors\": [\n      \"Network\"\n    ],\n     \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can inject arbitrary data into the application using this vulnerability.\",\n     \"additional_information\": \"This is issue #46241 in the golang/go repository, and it is also identified as CVE-2021-33195. The affected functions include `LookupCNAME`, `LookupSRV`, `LookupMX`, `LookupNS`, and `LookupAddr`. A possible fix involves checking returned names with the existing `isDomainName` function to ensure they conform to RFC 1035 LDH rules.\"\n  },\n    {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability is caused by the use of the `net.Lookup{Addr,CNAME,Host}` functions with the pure Go resolver, which does not validate or filter returned host name strings, leading to the possibility of injecting unexpected content if not sanitized.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n      \"Lack of output sanitization\"\n    ],\n    \"impact\": \"The impact is the injection of unexpected content. This could lead to a variety of consequences, including information disclosure, data modification, or denial of service, depending on the specific context where the unsanitized data is used.\",\n     \"attack_vectors\": [\n       \"Network\"\n      ],\n    \"attacker_capabilities\": \"An attacker would need to control DNS responses to inject arbitrary, invalid hostnames into the application that uses a vulnerable version of Go.\",\n     \"additional_information\": \"The vulnerability is assigned CVE-2021-33195. The `net` package in Go, specifically when using the pure Go resolver, does not filter or validate host name string types. This can be mitigated by checking returned names with the existing `isDomainName` function.\"\n  },\n    {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability arises from the fact that the `net.Lookup{Addr,CNAME,Host}` functions don't filter returned host name string types when using the pure Go resolver. This allows for invalid names to be returned, which, if used in unsanitized contexts, can lead to injection issues.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n     \"Lack of Output Sanitization\"\n    ],\n    \"impact\": \"The impact is potential injection of unexpected content. This could lead to vulnerabilities such as Cross-Site Scripting (XSS), data modification, or denial of service, depending on how the invalid hostname string is used.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can exploit this vulnerability by injecting arbitrary, invalid hostnames.\",\n    \"additional_information\": \"The affected functions are `net.Lookup{Addr, CNAME, Host}` when using the pure Go resolver. This issue is tracked as CVE-2021-33195. The recommended approach is to check the returned names using the `isDomainName` function, which applies RFC 1035 LDH rules.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability stems from the way the `net.Lookup{Addr,CNAME,Host}` functions handle DNS responses when using the pure Go resolver. They do not validate or filter the returned host name strings, allowing for invalid names that can cause injection vulnerabilities.\",\n     \"weaknesses\": [\n        \"Improper Input Validation\",\n       \"Lack of Output Sanitization\"\n      ],\n    \"impact\": \"The lack of validation allows for the injection of unexpected content, possibly leading to data modification, information disclosure, or denial of service (DoS) depending on how the application uses these names.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker could exploit this by controlling the DNS server or performing a man-in-the-middle attack to provide responses containing invalid host names.\",\n     \"additional_information\": \"The CVE ID for this vulnerability is CVE-2021-33195. The suggested remediation is to implement validation using the `isDomainName` function, which applies RFC 1035 LDH rules and filter out invalid names, or apply other sanitization techniques.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The net.Lookup functions return arbitrary values from DNS which do not follow the rules for domain names according to RFC 1035.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n      \"Lack of Output Sanitization\"\n    ],\n    \"impact\": \"When the returned names are used without sanitization, for instance in HTML, they can allow injection of unexpected content.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n     \"attacker_capabilities\": \"An attacker with the ability to influence DNS responses can inject arbitrary content.\",\n     \"additional_information\": \"This issue is identified as CVE-2021-33195, and it's noted that `LookupTXT` may still return arbitrary values that may require sanitization.\"\n  },\n    {\n     \"related_to_CVE\": \"CVE-2021-33195\",\n      \"root_cause\": \"The `net.Lookup{Addr,CNAME,Host}` functions do not properly filter returned host names when using the pure Go resolver. This can allow for invalid names to be returned to the caller, which can lead to injection vulnerabilities if used in unsanitized contexts.\",\n      \"weaknesses\": [\n        \"Improper Input Validation\",\n       \"Lack of Input Sanitization\"\n     ],\n      \"impact\": \"The use of invalid host names in an unsanitized context can lead to injection of unexpected content, potentially resulting in information disclosure, data modification, or denial of service.\",\n      \"attack_vectors\": [\n      \"Network\"\n      ],\n      \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can exploit this vulnerability.\",\n    \"additional_information\":\"This vulnerability is identified as CVE-2021-33195. The issue occurs because returned names are not checked against the RFC 1035 LDH rules. The cgo resolver might do some filtering, but this is not consistent. The fix should involve checking the returned names using the `isDomainName` function.\"\n  }\n]\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 1286 | Improper Validation of Syntactic Correctness of Input | Base | Allowed | sparse | 0.349 |\n| 2 | 917 | Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection') | Base | Allowed | sparse | 0.235 |\n| 3 | 113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | sparse | 0.226 |\n| 4 | 95 | Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') | Variant | Allowed | sparse | 0.225 |\n| 5 | 295 | Improper Certificate Validation | Base | Allowed | sparse | 0.222 |\n| 6 | 350 | Reliance on Reverse DNS Resolution for a Security-Critical Action | Variant | Allowed | dense | 0.542 |\n| 7 | 322 | Key Exchange without Entity Authentication | Base | Allowed | graph | 0.002 |\n| 8 | 74 | Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection') | Class | Discouraged | sparse | 0.221 |\n| 9 | 502 | Deserialization of Untrusted Data | Base | Allowed | sparse | 0.220 |\n| 10 | 22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | Base | Allowed | sparse | 0.220 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-1286: Improper Validation of Syntactic Correctness of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be well-formed - i.e., to comply with a certain syntax - but it does not validate or incorrectly validates that the input complies with the syntax.\n\n### Extended Description\n\n\nOften, complex inputs are expected to follow a particular syntax, which is either assumed by the input itself, or declared within metadata such as headers. The syntax could be for data exchange formats, markup languages, or even programming languages. When untrusted input is not properly validated for the expected syntax, attackers could cause parsing failures, trigger unexpected errors, or expose latent vulnerabilities that might not be directly exploitable if the input had conformed to the syntax.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2016-4029:** Chain: incorrect validation of intended decimal-based IP address format (CWE-1286) enables parsing of octal or hexadecimal formats (CWE-1389), allowing bypass of an SSRF protection mechanism (CWE-918).\n- **CVE-2007-5893:** HTTP request with missing protocol version number leads to crash\n\n\n\n\n## CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product constructs all or part of an expression language (EL) statement in a framework such as a Java Server Page (JSP) using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended EL statement before it is executed.\n\n### Extended Description\nFrameworks such as Java Server Page (JSP) allow a developer to insert executable expressions within otherwise-static content. When the developer is not aware of the executable nature of these expressions and/or does not disable them, then if an attacker can inject expressions, this could lead to code execution or other unexpected behaviors.\n\n### Alternative Terms\nEL Injection\n\n### Relationships\nChildOf -> CWE-77\nPeerOf -> CWE-1336\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified.\n\n**[Relationship]** In certain versions of Spring 3.0.5 and earlier, there was a vulnerability (CVE-2011-2730) in which Expression Language tags would be evaluated twice, which effectively exposed any application to EL injection. However, even for later versions, this weakness is still possible depending on configuration.\n\n\n\n### Observed Examples\n- **CVE-2021-44228:** Product does not neutralize ${xyz} style expressions, allowing remote code execution. (log4shell vulnerability in log4j)\n\n\n\n\n## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.\n\n### Extended Description\n\n\n HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. \n\n\nWhen an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as \"splitting\" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \\r, and LF is line feed, also given by %0a or \\n.\n\n\nIn addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \\t) and SP (space, also given as + sign or %20).\n\n\nThese types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second \"split\" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.\n\n\nHTTP response splitting weaknesses may be present when:\n\n\n  1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\n  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.\n\n\n\n### Alternative Terms\nHTTP Request Splitting\nHTTP Response Splitting\n\n### Relationships\nChildOf -> CWE-93\nCanPrecede -> CWE-79\nChildOf -> CWE-20\nChildOf -> CWE-436\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning\n- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs\n- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request\n\n\n\n\n## CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. \"eval\").\n\n### Extended Description\nThis may allow an attacker to execute arbitrary code, or at least modify what code can be executed.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Factors: special character errors can play a role in increasing the variety of code that can be injected, although some vulnerabilities do not require special characters at all, e.g. when a single function without arguments can be referenced and a terminator character is not necessary.\n\n\n\n### Observed Examples\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n- **CVE-2022-2054:** Python compiler uses eval() to execute malicious strings as Python code.\n- **CVE-2021-22204:** Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-295: Improper Certificate Validation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not validate, or incorrectly validates, a certificate.\n\n### Extended Description\nWhen a certificate is invalid or malicious, it might allow an attacker to spoof a trusted entity by interfering in the communication path between the host and client. The product might connect to a malicious host while believing it is a trusted host, or the product might be deceived into accepting spoofed data that appears to originate from a trusted host.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-287\nChildOf -> CWE-287\nPeerOf -> CWE-322\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2019-12496:** A Go framework for robotics, drones, and IoT devices skips verification of root CA certificates by default.\n- **CVE-2014-1266:** chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).\n- **CVE-2021-22909:** Chain: router's firmware update procedure uses curl with \"-k\" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).\n\n\n\n\n## CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product performs reverse DNS resolution on an IP address to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname.\n\n### Extended Description\n\n\nSince DNS names can be easily spoofed or misreported, and it may be difficult for the product to detect if a trusted DNS server has been compromised, DNS names do not constitute a valid authentication mechanism.\n\n\nWhen the product performs a reverse DNS resolution for an IP address, if an attacker controls the DNS server for that IP address, then the attacker can cause the server to return an arbitrary hostname. As a result, the attacker may be able to bypass authentication, cause the wrong hostname to be recorded in log files to hide activities, or perform other attacks.\n\n\nAttackers can spoof DNS names by either (1) compromising a DNS server and modifying its records (sometimes called DNS cache poisoning), or (2) having legitimate control over a DNS server associated with their IP address.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-290\nChildOf -> CWE-807\nCanPrecede -> CWE-923\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** CWE-350, CWE-247, and CWE-292 were merged into CWE-350 in CWE 2.5. CWE-247 was originally derived from Seven Pernicious Kingdoms, CWE-350 from PLOVER, and CWE-292 from CLASP. All taxonomies focused closely on the use of reverse DNS for authentication of incoming requests.\n\n\n\n### Observed Examples\n- **CVE-2001-1488:** Does not do double-reverse lookup to prevent DNS spoofing.\n- **CVE-2001-1500:** Does not verify reverse-resolved hostnames in DNS.\n- **CVE-2000-1221:** Authentication bypass using spoofed reverse-resolved DNS hostnames.\n\n\n\n\n## CWE-322: Key Exchange without Entity Authentication\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product performs a key exchange with an actor without verifying the identity of that actor.\n\n### Extended Description\nPerforming a key exchange will preserve the integrity of the information sent between two entities, but this will not guarantee that the entities are who they claim they are. This may enable an attacker to impersonate an actor by modifying traffic between the two entities. Typically, this involves a victim client that contacts a malicious server that is impersonating a trusted server. If the client skips authentication or ignores an authentication failure, the malicious server may request authentication information from the user. The malicious server can then use this authentication information to log in to the trusted server using the victim's credentials, sniff traffic between the victim and trusted server, etc.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-306\nCanPrecede -> CWE-923\nPeerOf -> CWE-295\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n\n\n\n## CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.\n\n### Extended Description\nSoftware or other automated logic has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for user-controlled input that leads to injection problems. Injection problems encompass a wide variety of issues -- all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features that classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-74 is high-level and often misused when lower-level weaknesses are more appropriate.\n**Comments:** Examine the children and descendants of this entry to find a more precise mapping.\n**Reasons:**\n- Frequent Misuse\n- Abstraction\n\n\n### Additional Notes\n**[Theoretical]** Many people treat injection only as an input validation problem (CWE-20) because many people do not distinguish between the consequence/attack (injection) and the protection mechanism that prevents the attack from succeeding. However, input validation is only one potential protection mechanism (output encoding is another), and there is a chaining relationship between improper input validation and the improper enforcement of the structure of messages to other components. Other issues not directly related to input validation, such as race conditions, could similarly impact message structure.\n\n\n\n### Observed Examples\n- **CVE-2024-5184:** API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.\n- **CVE-2022-36069:** Python-based dependency management tool avoids OS command injection when generating Git commands but allows injection of optional arguments with input beginning with a dash (CWE-88), potentially allowing for code execution.\n- **CVE-1999-0067:** Canonical example of OS command injection. CGI program does not neutralize \"|\" metacharacter when invoking a phonebook program.\n\n\n\n\n## CWE-502: Deserialization of Untrusted Data\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product deserializes untrusted data without sufficiently ensuring that the resulting data will be valid.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMarshaling, Unmarshaling: Marshaling and unmarshaling are effectively synonyms for serialization and deserialization, respectively.\nPickling, Unpickling: In Python, the \"pickle\" functionality is used to perform serialization and deserialization.\nPHP Object Injection: Some PHP application researchers use this term when attacking unsafe use of the unserialize() function; but it is also used for CWE-915.\n\n### Relationships\nChildOf -> CWE-913\nChildOf -> CWE-913\nPeerOf -> CWE-915\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** The relationships between CWE-502 and CWE-915 need further exploration. CWE-915 is more narrowly scoped to object modification, and is not necessarily used for deserialization.\n\n\n\n### Observed Examples\n- **CVE-2019-12799:** chain: bypass of untrusted deserialization issue (CWE-502) by using an assumed-trusted class (CWE-183)\n- **CVE-2015-8103:** Deserialization issue in commonly-used Java library allows remote execution.\n- **CVE-2015-4852:** Deserialization issue in commonly-used Java library allows remote execution.\n\n\n\n\n## CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.\n\n### Extended Description\n\n\nMany file operations are intended to take place within a restricted directory. By using special elements such as \"..\" and \"/\" separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the \"../\" sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as \"/usr/local/bin\" to access unexpected files. This is referred to as absolute path traversal.\n\n\n### Alternative Terms\nDirectory traversal\nPath traversal: \"Path traversal\" is preferred over \"directory traversal,\" but both terms are attack-focused.\n\n### Relationships\nChildOf -> CWE-706\nChildOf -> CWE-706\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to apply to a wider range of files. For example, the product may add \".txt\" to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.\n\n**[Relationship]** Pathname equivalence can be regarded as a type of canonicalization error.\n\n**[Relationship]** Some pathname equivalence issues are not directly related to directory traversal, rather are used to bypass security-relevant checks for whether a file/directory can be accessed by the attacker (e.g. a trailing \"/\" on a filename could bypass access rules that don't expect a trailing /, causing a server to provide the file when it normally would not).\n\n**[Terminology]** \n\nLike other weaknesses, terminology is often based on the types of manipulations used, instead of the underlying weaknesses. Some people use \"directory traversal\" only to refer to the injection of \"..\" and equivalent sequences whose specific meaning is to traverse directories.\n\n\nOther variants like \"absolute pathname\" and \"drive letter\" have the *effect* of directory traversal, but some people may not call it such, since it doesn't involve \"..\" or equivalent.\n\n\n**[Research Gap]** Many variants of path traversal attacks are probably under-studied with respect to root cause. CWE-790 and CWE-182 begin to cover part of this gap.\n\n**[Research Gap]** \n\nIncomplete diagnosis or reporting of vulnerabilities can make it difficult to know which variant is affected. For example, a researcher might say that \"..\\\" is vulnerable, but not test \"../\" which may also be vulnerable.\n\n\nAny combination of directory separators (\"/\", \"\\\", etc.) and numbers of \".\" (e.g. \"....\") can produce unique variants; for example, the \"//../\" variant is not listed (CVE-2004-0325). See this entry's children and lower-level descendants.\n\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n\n",
    "enhanced_query": "## Vulnerability Description\nGo before 1.15.13 and 1.16.x before 1.16.5 has functions for DNS lookups that do not validate replies from DNS servers, and thus a return value may contain an **unsafe injection** (e.g., XSS) that does not conform to the RFC1035 format.\n\n### Vulnerability Description Key Phrases\n- **weakness:** **unsafe injection**\n- **impact:** cross-site scripting\n- **product:** Go\n- **version:** before 1.15.13 and 1.16.x before 1.16.5\n- **component:** DNS lookup functions\n\n## CVE Reference Links Content Summary\n```json\n[\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The `net.Lookup{Addr,CNAME,Host}` functions, when using the pure Go resolver, don't filter returned host name string types, allowing invalid names to be returned to the caller. These names, if used in an unsanitized context, could lead to injection of unexpected content.\",\n    \"weaknesses\": [\n      \"Lack of input sanitization\",\n      \"Improper validation of hostnames\"\n    ],\n    \"impact\": \"Injection of unexpected content due to using invalid hostnames in unsanitized contexts which can lead to information disclosure, data modification, or denial of service.\",\n    \"attack_vectors\": [\n      \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker can exploit this vulnerability by controlling the DNS responses received by a vulnerable application, which may be achieved by controlling the DNS server or via a man-in-the-middle attack.\",\n    \"additional_information\": \"The vulnerability is present in Go versions before 1.15.12 and 1.16.x before 1.16.5. The vulnerability is triggered when the pure Go resolver is used. The cgo resolver may impose its own filtering, but this cannot be relied upon. The `isDomainName` function, which applies RFC 1035 LDH rules, can be used to validate returned names.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"Go versions prior to 1.15.13 and 1.16.x prior to 1.16.5 are susceptible to a vulnerability which, when successfully exploited, could lead to disclosure of sensitive information, addition or modification of data, or Denial of Service (DoS). This is due to the net.Lookup functions returning invalid hostnames.\",\n      \"weaknesses\": [\n        \"Improper input validation\"\n     ],\n     \"impact\": \"Disclosure of sensitive information, data modification, or denial of service (DoS).\",\n     \"attack_vectors\": [\n      \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker may be able to manipulate DNS results returned to a vulnerable system.\",\n      \"additional_information\": \"NetApp products are affected when they incorporate vulnerable versions of Golang. The provided link points to a Google Groups discussion related to Go 1.16.5 and 1.15.13 releases, which include security fixes.\"\n  },\n  {\n     \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The `net` package in Go does not properly validate hostnames returned by DNS lookups, allowing arbitrary values which do not follow RFC 1035 rules for domain names to be returned, leading to potential injection issues if used without sanitization.\",\n    \"weaknesses\": [\n      \"Improper input validation\",\n      \"Lack of sanitization for DNS query responses\"\n    ],\n    \"impact\": \"The vulnerability can lead to injection of unexpected content if arbitrary values from DNS responses are used without proper sanitization, potentially resulting in data modification, information disclosure, or a denial of service.\",\n    \"attack_vectors\": [\n      \"Network\"\n    ],\n     \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can inject arbitrary data into the application using this vulnerability.\",\n     \"additional_information\": \"This is issue #46241 in the golang/go repository, and it is also identified as CVE-2021-33195. The affected functions include `LookupCNAME`, `LookupSRV`, `LookupMX`, `LookupNS`, and `LookupAddr`. A possible fix involves checking returned names with the existing `isDomainName` function to ensure they conform to RFC 1035 LDH rules.\"\n  },\n    {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability is caused by the use of the `net.Lookup{Addr,CNAME,Host}` functions with the pure Go resolver, which does not validate or filter returned host name strings, leading to the possibility of injecting unexpected content if not sanitized.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n      \"Lack of output sanitization\"\n    ],\n    \"impact\": \"The impact is the injection of unexpected content. This could lead to a variety of consequences, including information disclosure, data modification, or denial of service, depending on the specific context where the unsanitized data is used.\",\n     \"attack_vectors\": [\n       \"Network\"\n      ],\n    \"attacker_capabilities\": \"An attacker would need to control DNS responses to inject arbitrary, invalid hostnames into the application that uses a vulnerable version of Go.\",\n     \"additional_information\": \"The vulnerability is assigned CVE-2021-33195. The `net` package in Go, specifically when using the pure Go resolver, does not filter or validate host name string types. This can be mitigated by checking returned names with the existing `isDomainName` function.\"\n  },\n    {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability arises from the fact that the `net.Lookup{Addr,CNAME,Host}` functions don't filter returned host name string types when using the pure Go resolver. This allows for invalid names to be returned, which, if used in unsanitized contexts, can lead to injection issues.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n     \"Lack of Output Sanitization\"\n    ],\n    \"impact\": \"The impact is potential injection of unexpected content. This could lead to vulnerabilities such as Cross-Site Scripting (XSS), data modification, or denial of service, depending on how the invalid hostname string is used.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can exploit this vulnerability by injecting arbitrary, invalid hostnames.\",\n    \"additional_information\": \"The affected functions are `net.Lookup{Addr, CNAME, Host}` when using the pure Go resolver. This issue is tracked as CVE-2021-33195. The recommended approach is to check the returned names using the `isDomainName` function, which applies RFC 1035 LDH rules.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The vulnerability stems from the way the `net.Lookup{Addr,CNAME,Host}` functions handle DNS responses when using the pure Go resolver. They do not validate or filter the returned host name strings, allowing for invalid names that can cause injection vulnerabilities.\",\n     \"weaknesses\": [\n        \"Improper Input Validation\",\n       \"Lack of Output Sanitization\"\n      ],\n    \"impact\": \"The lack of validation allows for the injection of unexpected content, possibly leading to data modification, information disclosure, or denial of service (DoS) depending on how the application uses these names.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n    \"attacker_capabilities\": \"An attacker could exploit this by controlling the DNS server or performing a man-in-the-middle attack to provide responses containing invalid host names.\",\n     \"additional_information\": \"The CVE ID for this vulnerability is CVE-2021-33195. The suggested remediation is to implement validation using the `isDomainName` function, which applies RFC 1035 LDH rules and filter out invalid names, or apply other sanitization techniques.\"\n  },\n  {\n    \"related_to_CVE\": \"CVE-2021-33195\",\n    \"root_cause\": \"The net.Lookup functions return arbitrary values from DNS which do not follow the rules for domain names according to RFC 1035.\",\n    \"weaknesses\": [\n      \"Improper Input Validation\",\n      \"Lack of Output Sanitization\"\n    ],\n    \"impact\": \"When the returned names are used without sanitization, for instance in HTML, they can allow injection of unexpected content.\",\n    \"attack_vectors\": [\n     \"Network\"\n    ],\n     \"attacker_capabilities\": \"An attacker with the ability to influence DNS responses can inject arbitrary content.\",\n     \"additional_information\": \"This issue is identified as CVE-2021-33195, and it's noted that `LookupTXT` may still return arbitrary values that may require sanitization.\"\n  },\n    {\n     \"related_to_CVE\": \"CVE-2021-33195\",\n      \"root_cause\": \"The `net.Lookup{Addr,CNAME,Host}` functions do not properly filter returned host names when using the pure Go resolver. This can allow for invalid names to be returned to the caller, which can lead to injection vulnerabilities if used in unsanitized contexts.\",\n      \"weaknesses\": [\n        \"Improper Input Validation\",\n       \"Lack of Input Sanitization\"\n     ],\n      \"impact\": \"The use of invalid host names in an unsanitized context can lead to injection of unexpected content, potentially resulting in information disclosure, data modification, or denial of service.\",\n      \"attack_vectors\": [\n      \"Network\"\n      ],\n      \"attacker_capabilities\": \"An attacker capable of manipulating DNS responses can exploit this vulnerability.\",\n    \"additional_information\":\"This vulnerability is identified as CVE-2021-33195. The issue occurs because returned names are not checked against the RFC 1035 LDH rules. The cgo resolver might do some filtering, but this is not consistent. The fix should involve checking the returned names using the `isDomainName` function.\"\n  }\n]\n```\n\n## Retriever Results\n\n### Top Combined Results\n\n| Rank | CWE ID | Name | Abstraction | Usage  | Retrievers | Individual Scores |\n|------|--------|------|-------------|-------|------------|-------------------|\n| 1 | 1286 | Improper Validation of Syntactic Correctness of Input | Base | Allowed | sparse | 0.349 |\n| 2 | 917 | Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection') | Base | Allowed | sparse | 0.235 |\n| 3 | 113 | Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting') | Variant | Allowed | sparse | 0.226 |\n| 4 | 95 | Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection') | Variant | Allowed | sparse | 0.225 |\n| 5 | 295 | Improper Certificate Validation | Base | Allowed | sparse | 0.222 |\n| 6 | 350 | Reliance on Reverse DNS Resolution for a Security-Critical Action | Variant | Allowed | dense | 0.542 |\n| 7 | 322 | Key Exchange without Entity Authentication | Base | Allowed | graph | 0.002 |\n| 8 | 74 | Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection') | Class | Discouraged | sparse | 0.221 |\n| 9 | 502 | Deserialization of Untrusted Data | Base | Allowed | sparse | 0.220 |\n| 10 | 22 | Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') | Base | Allowed | sparse | 0.220 |\n\n\n\n# Complete CWE Specifications\n\n\n## CWE-1286: Improper Validation of Syntactic Correctness of Input\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product receives input that is expected to be well-formed - i.e., to comply with a certain syntax - but it does not validate or incorrectly validates that the input complies with the syntax.\n\n### Extended Description\n\n\nOften, complex inputs are expected to follow a particular syntax, which is either assumed by the input itself, or declared within metadata such as headers. The syntax could be for data exchange formats, markup languages, or even programming languages. When untrusted input is not properly validated for the expected syntax, attackers could cause parsing failures, trigger unexpected errors, or expose latent vulnerabilities that might not be directly exploitable if the input had conformed to the syntax.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-20\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** This entry is still under development and will continue to see updates and content improvements.\n\n\n\n### Observed Examples\n- **CVE-2016-4029:** Chain: incorrect validation of intended decimal-based IP address format (CWE-1286) enables parsing of octal or hexadecimal formats (CWE-1389), allowing bypass of an SSRF protection mechanism (CWE-918).\n- **CVE-2007-5893:** HTTP request with missing protocol version number leads to crash\n\n\n\n\n## CWE-917: Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')\n**Abstraction:** Base\n**Status:** Incomplete\n\n### Description\nThe product constructs all or part of an expression language (EL) statement in a framework such as a Java Server Page (JSP) using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended EL statement before it is executed.\n\n### Extended Description\nFrameworks such as Java Server Page (JSP) allow a developer to insert executable expressions within otherwise-static content. When the developer is not aware of the executable nature of these expressions and/or does not disable them, then if an attacker can inject expressions, this could lead to code execution or other unexpected behaviors.\n\n### Alternative Terms\nEL Injection\n\n### Relationships\nChildOf -> CWE-77\nPeerOf -> CWE-1336\nChildOf -> CWE-74\nChildOf -> CWE-77\nChildOf -> CWE-77\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** The interrelationships and differences between CWE-917 and CWE-1336 need to be further clarified.\n\n**[Relationship]** In certain versions of Spring 3.0.5 and earlier, there was a vulnerability (CVE-2011-2730) in which Expression Language tags would be evaluated twice, which effectively exposed any application to EL injection. However, even for later versions, this weakness is still possible depending on configuration.\n\n\n\n### Observed Examples\n- **CVE-2021-44228:** Product does not neutralize ${xyz} style expressions, allowing remote code execution. (log4shell vulnerability in log4j)\n\n\n\n\n## CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.\n\n### Extended Description\n\n\n HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. \n\n\nWhen an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as \"splitting\" the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or \\r, and LF is line feed, also given by %0a or \\n.\n\n\nIn addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or \\t) and SP (space, also given as + sign or %20).\n\n\nThese types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second \"split\" message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks.\n\n\nHTTP response splitting weaknesses may be present when:\n\n\n  1. Data enters a web application through an untrusted source, most frequently an HTTP request.\n\n  1. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.\n\n\n\n### Alternative Terms\nHTTP Request Splitting\nHTTP Response Splitting\n\n### Relationships\nChildOf -> CWE-93\nCanPrecede -> CWE-79\nChildOf -> CWE-20\nChildOf -> CWE-436\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2020-15811:** Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning\n- **CVE-2021-41084:** Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs\n- **CVE-2018-12116:** Javascript-based framework allows request splitting through a path option of an HTTP request\n\n\n\n\n## CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')\n**Abstraction:** Variant\n**Status:** Incomplete\n\n### Description\nThe product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. \"eval\").\n\n### Extended Description\nThis may allow an attacker to execute arbitrary code, or at least modify what code can be executed.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-94\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** Factors: special character errors can play a role in increasing the variety of code that can be injected, although some vulnerabilities do not require special characters at all, e.g. when a single function without arguments can be referenced and a terminator character is not necessary.\n\n\n\n### Observed Examples\n- **CVE-2024-4181:** Framework for LLM applications allows eval injection via a crafted response from a hosting provider.\n- **CVE-2022-2054:** Python compiler uses eval() to execute malicious strings as Python code.\n- **CVE-2021-22204:** Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.\n\n\n\n\n## CWE-295: Improper Certificate Validation\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product does not validate, or incorrectly validates, a certificate.\n\n### Extended Description\nWhen a certificate is invalid or malicious, it might allow an attacker to spoof a trusted entity by interfering in the communication path between the host and client. The product might connect to a malicious host while believing it is a trusted host, or the product might be deceived into accepting spoofed data that appears to originate from a trusted host.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-287\nChildOf -> CWE-287\nPeerOf -> CWE-322\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n### Observed Examples\n- **CVE-2019-12496:** A Go framework for robotics, drones, and IoT devices skips verification of root CA certificates by default.\n- **CVE-2014-1266:** chain: incorrect \"goto\" in Apple SSL product bypasses certificate validation, allowing Adversary-in-the-Middle (AITM) attack (Apple \"goto fail\" bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).\n- **CVE-2021-22909:** Chain: router's firmware update procedure uses curl with \"-k\" (insecure) option that disables certificate validation (CWE-295), allowing adversary-in-the-middle (AITM) compromise with a malicious firmware image (CWE-494).\n\n\n\n\n## CWE-350: Reliance on Reverse DNS Resolution for a Security-Critical Action\n**Abstraction:** Variant\n**Status:** Draft\n\n### Description\nThe product performs reverse DNS resolution on an IP address to obtain the hostname and make a security decision, but it does not properly ensure that the IP address is truly associated with the hostname.\n\n### Extended Description\n\n\nSince DNS names can be easily spoofed or misreported, and it may be difficult for the product to detect if a trusted DNS server has been compromised, DNS names do not constitute a valid authentication mechanism.\n\n\nWhen the product performs a reverse DNS resolution for an IP address, if an attacker controls the DNS server for that IP address, then the attacker can cause the server to return an arbitrary hostname. As a result, the attacker may be able to bypass authentication, cause the wrong hostname to be recorded in log files to hide activities, or perform other attacks.\n\n\nAttackers can spoof DNS names by either (1) compromising a DNS server and modifying its records (sometimes called DNS cache poisoning), or (2) having legitimate control over a DNS server associated with their IP address.\n\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-290\nChildOf -> CWE-807\nCanPrecede -> CWE-923\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Variant level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** CWE-350, CWE-247, and CWE-292 were merged into CWE-350 in CWE 2.5. CWE-247 was originally derived from Seven Pernicious Kingdoms, CWE-350 from PLOVER, and CWE-292 from CLASP. All taxonomies focused closely on the use of reverse DNS for authentication of incoming requests.\n\n\n\n### Observed Examples\n- **CVE-2001-1488:** Does not do double-reverse lookup to prevent DNS spoofing.\n- **CVE-2001-1500:** Does not verify reverse-resolved hostnames in DNS.\n- **CVE-2000-1221:** Authentication bypass using spoofed reverse-resolved DNS hostnames.\n\n\n\n\n## CWE-322: Key Exchange without Entity Authentication\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product performs a key exchange with an actor without verifying the identity of that actor.\n\n### Extended Description\nPerforming a key exchange will preserve the integrity of the information sent between two entities, but this will not guarantee that the entities are who they claim they are. This may enable an attacker to impersonate an actor by modifying traffic between the two entities. Typically, this involves a victim client that contacts a malicious server that is impersonating a trusted server. If the client skips authentication or ignores an authentication failure, the malicious server may request authentication information from the user. The malicious server can then use this authentication information to log in to the trusted server using the victim's credentials, sniff traffic between the victim and trusted server, etc.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-306\nCanPrecede -> CWE-923\nPeerOf -> CWE-295\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n\n\n\n\n## CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')\n**Abstraction:** Class\n**Status:** Incomplete\n\n### Description\nThe product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.\n\n### Extended Description\nSoftware or other automated logic has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for user-controlled input that leads to injection problems. Injection problems encompass a wide variety of issues -- all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features that classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed.\n\n### Alternative Terms\nNone\n\n### Relationships\nChildOf -> CWE-707\n\n### Mapping Guidance\n**Usage:** Discouraged\n**Rationale:** CWE-74 is high-level and often misused when lower-level weaknesses are more appropriate.\n**Comments:** Examine the children and descendants of this entry to find a more precise mapping.\n**Reasons:**\n- Frequent Misuse\n- Abstraction\n\n\n### Additional Notes\n**[Theoretical]** Many people treat injection only as an input validation problem (CWE-20) because many people do not distinguish between the consequence/attack (injection) and the protection mechanism that prevents the attack from succeeding. However, input validation is only one potential protection mechanism (output encoding is another), and there is a chaining relationship between improper input validation and the improper enforcement of the structure of messages to other components. Other issues not directly related to input validation, such as race conditions, could similarly impact message structure.\n\n\n\n### Observed Examples\n- **CVE-2024-5184:** API service using a large generative AI model allows direct prompt injection to leak hard-coded system prompts or execute other prompts.\n- **CVE-2022-36069:** Python-based dependency management tool avoids OS command injection when generating Git commands but allows injection of optional arguments with input beginning with a dash (CWE-88), potentially allowing for code execution.\n- **CVE-1999-0067:** Canonical example of OS command injection. CGI program does not neutralize \"|\" metacharacter when invoking a phonebook program.\n\n\n\n\n## CWE-502: Deserialization of Untrusted Data\n**Abstraction:** Base\n**Status:** Draft\n\n### Description\nThe product deserializes untrusted data without sufficiently ensuring that the resulting data will be valid.\n\n### Extended Description\nNot provided\n\n### Alternative Terms\nMarshaling, Unmarshaling: Marshaling and unmarshaling are effectively synonyms for serialization and deserialization, respectively.\nPickling, Unpickling: In Python, the \"pickle\" functionality is used to perform serialization and deserialization.\nPHP Object Injection: Some PHP application researchers use this term when attacking unsafe use of the unserialize() function; but it is also used for CWE-915.\n\n### Relationships\nChildOf -> CWE-913\nChildOf -> CWE-913\nPeerOf -> CWE-915\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Maintenance]** The relationships between CWE-502 and CWE-915 need further exploration. CWE-915 is more narrowly scoped to object modification, and is not necessarily used for deserialization.\n\n\n\n### Observed Examples\n- **CVE-2019-12799:** chain: bypass of untrusted deserialization issue (CWE-502) by using an assumed-trusted class (CWE-183)\n- **CVE-2015-8103:** Deserialization issue in commonly-used Java library allows remote execution.\n- **CVE-2015-4852:** Deserialization issue in commonly-used Java library allows remote execution.\n\n\n\n\n## CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')\n**Abstraction:** Base\n**Status:** Stable\n\n### Description\nThe product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.\n\n### Extended Description\n\n\nMany file operations are intended to take place within a restricted directory. By using special elements such as \"..\" and \"/\" separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the \"../\" sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as \"/usr/local/bin\" to access unexpected files. This is referred to as absolute path traversal.\n\n\n### Alternative Terms\nDirectory traversal\nPath traversal: \"Path traversal\" is preferred over \"directory traversal,\" but both terms are attack-focused.\n\n### Relationships\nChildOf -> CWE-706\nChildOf -> CWE-706\nChildOf -> CWE-668\n\n### Mapping Guidance\n**Usage:** Allowed\n**Rationale:** This CWE entry is at the Base level of abstraction, which is a preferred level of abstraction for mapping to the root causes of vulnerabilities.\n**Comments:** Carefully read both the name and description to ensure that this mapping is an appropriate fit. Do not try to 'force' a mapping to a lower-level Base/Variant simply to comply with this preferred level of abstraction.\n**Reasons:**\n- Acceptable-Use\n\n\n### Additional Notes\n**[Other]** In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to apply to a wider range of files. For example, the product may add \".txt\" to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.\n\n**[Relationship]** Pathname equivalence can be regarded as a type of canonicalization error.\n\n**[Relationship]** Some pathname equivalence issues are not directly related to directory traversal, rather are used to bypass security-relevant checks for whether a file/directory can be accessed by the attacker (e.g. a trailing \"/\" on a filename could bypass access rules that don't expect a trailing /, causing a server to provide the file when it normally would not).\n\n**[Terminology]** \n\nLike other weaknesses, terminology is often based on the types of manipulations used, instead of the underlying weaknesses. Some people use \"directory traversal\" only to refer to the injection of \"..\" and equivalent sequences whose specific meaning is to traverse directories.\n\n\nOther variants like \"absolute pathname\" and \"drive letter\" have the *effect* of directory traversal, but some people may not call it such, since it doesn't involve \"..\" or equivalent.\n\n\n**[Research Gap]** Many variants of path traversal attacks are probably under-studied with respect to root cause. CWE-790 and CWE-182 begin to cover part of this gap.\n\n**[Research Gap]** \n\nIncomplete diagnosis or reporting of vulnerabilities can make it difficult to know which variant is affected. For example, a researcher might say that \"..\\\" is vulnerable, but not test \"../\" which may also be vulnerable.\n\n\nAny combination of directory separators (\"/\", \"\\\", etc.) and numbers of \".\" (e.g. \"....\") can produce unique variants; for example, the \"//../\" variant is not listed (CVE-2004-0325). See this entry's children and lower-level descendants.\n\n\n\n\n### Observed Examples\n- **CVE-2024-37032:** Large language model (LLM) management tool does not validate the format of a digest value (CWE-1287) from a private, untrusted model registry, enabling relative path traversal (CWE-23), a.k.a. Probllama\n- **CVE-2024-4315:** Chain: API for text generation using Large Language Models (LLMs) does not include the \"\\\" Windows folder separator in its denylist (CWE-184) when attempting to prevent Local File Inclusion via path traversal (CWE-22), allowing deletion of arbitrary files on Windows systems.\n- **CVE-2022-45918:** Chain: a learning management tool debugger uses external input to locate previous session logs (CWE-73) and does not properly validate the given path (CWE-20), allowing for filesystem path traversal using \"../\" sequences (CWE-24)\n\n Consider specifically these CWEs: CWE-113 CWE-41 CWE-1289 CWE-116 CWE-74 CWE-917 CWE-22 CWE-295 CWE-23 CWE-184",
    "cwe_mentions": [
      "CWE-113",
      "CWE-41",
      "CWE-1289",
      "CWE-116",
      "CWE-74",
      "CWE-917",
      "CWE-22",
      "CWE-295",
      "CWE-23",
      "CWE-184"
    ],
    "search_time": 3.0025157928466797
  },
  "timestamp": "2025-04-02 07:27:01",
  "cve_id": "unknown",
  "result_count": 10,
  "results": [
    {
      "cwe_id": "322",
      "name": "Key Exchange without Entity Authentication",
      "type": "base",
      "score": 5.031000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "183",
      "name": "Permissive List of Allowed Inputs",
      "type": "base",
      "score": 4.3888,
      "relationship_count": 0
    },
    {
      "cwe_id": "22",
      "name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "494",
      "name": "Download of Code Without Integrity Check",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "79",
      "name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
      "type": "base",
      "score": 4.329000000000001,
      "relationship_count": 0
    },
    {
      "cwe_id": "350",
      "name": "Reliance on Reverse DNS Resolution for a Security-Critical Action",
      "type": "variant",
      "score": 3.8784,
      "relationship_count": 0
    },
    {
      "cwe_id": "1336",
      "name": "Improper Neutralization of Special Elements Used in a Template Engine",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "915",
      "name": "Improperly Controlled Modification of Dynamically-Determined Object Attributes",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "502",
      "name": "Deserialization of Untrusted Data",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    },
    {
      "cwe_id": "625",
      "name": "Permissive Regular Expression",
      "type": "base",
      "score": 3.6399999999999997,
      "relationship_count": 0
    }
  ]
}